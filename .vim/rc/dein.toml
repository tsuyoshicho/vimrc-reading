# based on http://qiita.com/kawaz/items/ee725f6214f91337b42b
[[plugins]]
repo = 'Shougo/dein.vim'
merged = 0
hook_add = '''
  " dein fixed setting in vimrc
  " if try branch, manual `git switch` needed

  " setting for dein

  " process
  let g:dein#install_max_processes = g:user.system.cpunum

  " coefficient
  if g:user.system.windows
    " windows x4
    " io heavy & process heavy -> stay wait queue
    let g:dein#install_max_processes = g:dein#install_max_processes * 4
  else
    " non windows x2
    let g:dein#install_max_processes = g:dein#install_max_processes * 2
  endif
'''
hook_post_source = '''
  " dein no depend trick(need vim-pass)
  if dein#tap('vim-pass')
    function! s:dein_token_set() abort
      let g:dein#install_github_api_token = pass#get('Develop/Github')
    endfunction

    call timer_start(0, { -> s:dein_token_set() })

    command! DeinUpdateStart call dein#check_update(v:true)
  else
    command! DeinUpdateStart call dein#update()
  endif
'''

# ToC
# WIP
# 1.1 oooOoooO Core / Library
# 1.2 oooOooOo Terminal
# 1.3 oooOooOO Motion
# 1.4          Action
# 1.4          Filer
# 1.5          Utils
# 1.6          Command
# 1.7          Display
# 1.8          Colorscheme support
# Quick Fix
# Session
# Folding
# Split/Join
# File Header
## textobj & operator
# textobj
# operator
# Startup
# Doc & File & Web
# CtrlP
# QuickRun
# Git
# Edit operation

# Core & Util
[[plugins]]
# repo = 'vim-jp/vital.vim'
repo = 'tsuyoshicho/vital.vim'
rev  = 'develop'
merged = 0
hook_post_source = '''
  " vital use
  let g:V = vital#of('vital')

  " vitalize need vital git repo
  " need merged=0
  " let g:vitalizer#vital_dir = ...
'''

[[plugins]]
repo = 'lambdalisue/vital-Whisky'
merged = 0
depends = ['vital.vim']

[[plugins]]
repo = 'lambdalisue/vital-ArgumentParser'
merged = 0
depends = ['vital.vim']

[[plugins]]
repo = 'LumaKernel/vital-Luv'
merged = 0
depends = ['vital.vim']

[[plugins]]
repo = 'Shougo/vimproc.vim'
merged = 0
hook_post_update = '''
  " from 0Delta/vimrc
  " if !has('nvim')
  "   call dein#add('roxma/nvim-yarp')
  "   call dein#add('roxma/vim-hug-neovim-rpc')
  " endif

  if dein#util#_is_windows()
    let cmd = 'tools\\update-dll-mingw'
  elseif dein#util#_is_cygwin()
    let cmd = 'make -f make_cygwin.mak'
  elseif executable('gmake')
    let cmd = 'gmake'
  else
    let cmd = 'make'
  endif
  let g:dein#plugin.build = cmd
'''

# [[plugins]]
# repo = 'prabirshrestha/async.vim'

[[plugins]]
repo = 'mattn/vimtweak'
merged = 0

# 'vimtweak' depends windows only
[[plugins]]
repo = 'tsuyoshicho/transparency.vim'
depends = ['vimtweak']
hook_add = '''
  let g:transparency_config = {
      \  'active'   : 90,
      \  'inactive' : 60
      \ }
  let g:transparency_ctermbg_none = 1
'''
hook_post_source = '''
  if get(g:, 'transparency_activate', 0)
    " nmap --- <Plug>(TransparencyOn)
    " nmap --- <Plug>(TransparencyOff)
    nmap <F4> <Plug>(TransparencyToggle)
  endif
'''

[[plugins]]
repo = 'kana/vim-submode'
hook_add = '''
  " submode option

  " show submode
  " show lightline status
  let g:submode_always_show_submode = 0  " rel 'showmode' status

  " leave submode keytype not ignore
  let g:submode_keep_leaving_key = 1

  " submode timeout?
  " let g:submode_timeout = 1              " rel 'timeout' status

  " submode timeout len
  let g:submode_timeoutlen = 1000 * 3    " 3sec (unit:msec)
'''
hook_post_source = '''
  " global and basic vim bind setting
  " undo/redo
  call submode#enter_with('undo/redo', 'n', '', 'g-', 'g-')
  call submode#enter_with('undo/redo', 'n', '', 'g+', 'g+')
  call submode#leave_with('undo/redo', 'n', '', '<Esc>')
  call submode#map('undo/redo', 'n', '', '-', 'g-')
  call submode#map('undo/redo', 'n', '', 'p', 'g-')
  call submode#map('undo/redo', 'n', '', '+', 'g+')
  call submode#map('undo/redo', 'n', '', 'n', 'g+')

  " tab move
  call submode#enter_with('tabmove', 'n', '', 'gt', 'gt')
  call submode#enter_with('tabmove', 'n', '', 'gT', 'gT')
  call submode#enter_with('tabmove', 'n', '', '<Leader><Left>',  ':tabmove -1<CR>')
  call submode#enter_with('tabmove', 'n', '', '<Leader><Right>', ':tabmove +1<CR>')
  call submode#map('tabmove', 'n', '', 't', 'gt')
  call submode#map('tabmove', 'n', '', 'n', 'gt')
  call submode#map('tabmove', 'n', '', 'T', 'gT')
  call submode#map('tabmove', 'n', '', 'p', 'gT')
  call submode#map('tabmove', 'n', '', '<Left>',  ':tabmove -1<CR>')
  call submode#map('tabmove', 'n', '', 'k',  ':tabmove -1<CR>')
  call submode#map('tabmove', 'n', '', '<Right>', ':tabmove +1<CR>')
  call submode#map('tabmove', 'n', '', 'j', ':tabmove +1<CR>')
'''

# Terminal
##############
[[plugins]]
# repo = 'kyoh86/vim-editerm'
repo = 'lambdalisue/edita.vim'

[[plugins]]
repo = 'tyru/empty-prompt.vim'
depends = ['vital.vim']
hook_add = '''
  " : works as <C-w>:
  autocmd MyAutoGroup VimEnter * call empty_prompt#map(#{lhs: ':', rhs: '<C-w>:'})
  " <Esc> works as <C-w>N
  autocmd MyAutoGroup VimEnter * call empty_prompt#map(#{lhs: '<Esc>', rhs: '<C-w>N'})
'''
hook_post_source = '''
  let s:prompt = {}

  let s:prompt['cmd'] = '>'
  let s:prompt['nix'] = '$'

  let s:starship_config = expand(g:user.dir.config_home . '/starship.toml')
  let s:starship = {}
  if filereadable(s:starship_config)
    let s:TOML = g:V.import('Text.TOML')
    let s:starship = s:TOML.parse_file(s:starship_config)
    unlet s:TOML
  endif

  let s:prompt['starship'] = '‚ùØ'
  if has_key(s:starship,'character')
    if has_key(s:starship.character, 'symbol')
      let s:prompt['starship'] = s:starship.character.symbol
    endif
  endif

  let s:result = '\(' . escape(join(values(s:prompt), '|'), '\|$')  . '\)\s*$'

  let g:empty_prompt#pattern = s:result
  unlet s:result
'''

[[plugins]]
repo = 'tyru/sync-term-cwd.vim'
hook_post_source = '''
  " Setup
  " Add below to your .bashrc / .zshrc.
  "   source (this repository)/macros/synctermcwd.sh
  " See vim help (:help synctermcwd) for more configuration.
  "
  " like editerm
  let $SYNCTERMCWD_SRC_PATH = expand(g:dein#plugin.rtp . '/macros/synctermcwd.sh')
'''

[[plugins]]
repo = 'rbtnn/vim-pterm'

# [[plugins]]
# repo = 'terryma/vim-multiple-cursors'
# hook_add = '''
#   let g:multi_cursor_use_default_mapping = 0
#
#   " Default mapping
#   let g:multi_cursor_start_word_key      = '<C-o>'
#   let g:multi_cursor_select_all_word_key = '<A-o>'
#   let g:multi_cursor_start_key           = 'g<C-o>'
#   let g:multi_cursor_select_all_key      = 'g<A-o>'
#   let g:multi_cursor_next_key            = 'm<C-n>'
#   let g:multi_cursor_prev_key            = 'm<C-p>'
#   let g:multi_cursor_skip_key            = '<C-x>'
#   let g:multi_cursor_quit_key            = 'g<Esc>'
# '''

# Motion
##############
[[plugins]]
repo = 'machakann/vim-swap'
hook_add = '''
  omap i,, <Plug>(swap-textobject-i)
  xmap i,, <Plug>(swap-textobject-i)
  omap a,, <Plug>(swap-textobject-a)
  xmap a,, <Plug>(swap-textobject-a)
'''

# [[plugins]]
# repo = 'yuttie/comfortable-motion.vim'
# hook_add = '''
#   " overwrite j/k motion
#   let g:comfortable_motion_scroll_down_key = "j"
#   let g:comfortable_motion_scroll_up_key = "k"
#
#   " Friction & Air Resistance
#   " default
#   " let g:comfortable_motion_interval = 1000.0 / 60
#   " let g:comfortable_motion_friction = 80.0
#   " let g:comfortable_motion_air_drag = 2.0
#
#   " see https://liginc.co.jp/469142
#   " let g:comfortable_motion_interval = 2400.0 / 60
#   " let g:comfortable_motion_friction = 100.0
#   " let g:comfortable_motion_air_drag = 3.0
# '''
# hook_post_source = '''
#   noremap <silent> <ScrollWheelDown> :call comfortable_motion#flick(40)<CR>
#   noremap <silent> <ScrollWheelUp>   :call comfortable_motion#flick(-40)<CR>
# '''

# Action
##############
[[plugins]]
repo = 'psliwka/vim-smoothie'

[[plugins]]
repo = 'rhysd/accelerated-jk'
hook_post_source = '''
  nmap j <Plug>(accelerated_jk_gj)
  nmap k <Plug>(accelerated_jk_gk)
  " nmap j <Plug>(accelerated_jk_gj_position)
  " nmap k <Plug>(accelerated_jk_gk_position)
'''

# Filer
##############
[[plugins]]
repo = 'lambdalisue/fern.vim'
# depends = ['memolist.vim', 'junkfile.vim']
hook_add = '''
  " let g:fern#loglevel = g:fern#DEBUG

  function! s:fern_init() abort
    setlocal nonumber
    setlocal norelativenumber
    setlocal foldcolumn=0
    setlocal signcolumn=yes

    " mapping
    nmap <buffer><silent> <C-m>
      \ <Plug>(fern-action-open-or-enter)
      \ <Plug>(fern-wait)
      \ <Plug>(fern-action-tcd:root)

    " define autocmd for buffer
    autocmd BufEnter <buffer> call feedkeys("\<Plug>(fern-action-tcd:root)")
  endfunction

  augroup vimrc_init-fern
    autocmd!
    autocmd FileType fern nested call s:fern_init()
  augroup END
'''
hook_post_source = '''
  " thanks lambdalisue
  function! s:smart_path() abort
    if !empty(&buftype) || bufname('%') =~# '^[^:]\+://'
      return fnamemodify('.', ':p')
    endif
    return fnamemodify(expand('%'), ':p:h')
  endfunction

  " conflict workaround : prefix <Leader>F as Fern
  nnoremap <silent> <Leader>Fb :<C-u>Fern bookmark:///<CR>
  nnoremap <silent> <Leader>Fe :<C-u>Fern <C-r>=<SID>smart_path()<CR> -reveal=%<CR>
  nnoremap <silent> <Leader>Ff :<C-u>Fern . -drawer -toggle -reveal=%<CR>
  nnoremap <silent> <Leader>Ft :<C-u>Fern . -opener=tabedit -reveal=%<CR>
  if exists('g:memolist_path')
    nnoremap <silent> <Leader>Fm :<C-u>Fern <C-r>=expand(g:memolist_path)<CR> -drawer -toggle -reveal=%<CR>
  endif
  if exists('g:junkfile#directory')
    nnoremap <silent> <Leader>Fj :<C-u>Fern <C-r>=expand(g:junkfile#directory)<CR> -drawer -toggle -reveal=%<CR>
  endif
'''

[[plugins]]
# repo = 'lambdalisue/fern-renderer-devicons.vim'
repo = 'lambdalisue/fern-renderer-nerdfont.vim'
# depends = ['fern.vim', 'vim-devicons']
depends = ['fern.vim', 'nerdfont.vim']
hook_add = '''
  " let g:fern#renderer = 'devicons'
  let g:fern#renderer = "nerdfont"
'''

[[plugins]]
repo = 'lambdalisue/fern-hijack.vim'
depends = ['fern.vim']

[[plugins]]
repo = 'lambdalisue/fern-comparator-lexical.vim'
depends = ['fern.vim']
hook_add = '''
  let g:fern#comparator = 'lexical'
'''

[[plugins]]
repo = 'lambdalisue/fern-bookmark.vim'
depends = ['fern.vim']
hook_add = '''
  let g:fern#scheme#bookmark#store#file = expand(g:user.dir.vim . '/bookmark.json')
'''

[[plugins]]
repo = 'hrsh7th/fern-mapping-call-function.vim'
depends = ['fern.vim']
hook_add = '''
  function! s:fern_init_funcall() abort
    " Map to your custom function.
    " nmap <silent><buffer><Tab> <Plug>(fern-action-call-function:project_top)
  endfunction

  augroup vimrc_init-fern-funcall
    autocmd!
    autocmd! FileType fern call s:fern_init_funcall()
  augroup END
'''
hook_post_source = '''
  " Add your custom function to mapping.
  " function! s:fern_project_top(helper) abort
  "   let l:node = a:helper.sync.get_current_node()
  "   let l:proj = s:detect_project_root(l:node._path)
  "   execute printf('Fern %s', fnameescape(l:proj))
  " endfunction
  " :w

  " call fern#mapping#call_function#add('project_top', function('s:fern_project_top'))
'''

[[plugins]]
repo = 'hrsh7th/fern-mapping-collapse-or-leave.vim'
depends = ['fern.vim']
hook_add = '''
  let g:fern#mapping#collapse_or_leave#disable_default_mappings = 1

  function! s:fern_init_collapse_or_leave() abort
    nmap <buffer><silent> h
      \ <Plug>(fern-action-collapse-or-leave)
      \ <Plug>(fern-wait)
      \ <Plug>(fern-action-tcd:root)
  endfunction

  augroup vimrc_init-fern-collapse-or-leave
    autocmd!
    autocmd FileType fern nested call s:fern_init_collapse_or_leave()
  augroup END
'''

[[plugins]]
repo = 'lambdalisue/fern-mapping-project-top.vim'
depends = ['fern.vim']
hook_add = '''
  function! s:fern_init_project_top() abort
    nmap <buffer><silent> ^ <Plug>(fern-action-project-top)
  endfunction

  augroup vimrc_init-fern-project-top
    autocmd!
    autocmd FileType fern nested call s:fern_init_project_top()
  augroup END
'''

[[plugins]]
repo = 'lambdalisue/fern-mapping-mark-children.vim'
depends = ['fern.vim']

[[plugins]]
repo = 'lambdalisue/fern-mapping-quickfix.vim'
depends = ['fern.vim']

[[plugins]]
repo = 'lambdalisue/fern-mapping-git.vim'
depends = ['fern.vim']

[[plugins]]
repo = 'lambdalisue/fern-git-status.vim'
depends = ['fern.vim']
hook_add = '''
  " Disable listing ignored files/directories
  let g:fern_git_status#disable_ignored = 1

  " Disable listing untracked files
  let g:fern_git_status#disable_untracked = 1

  " Disable listing status of submodules
  " let g:fern_git_status#disable_submodules = 1

  " Disable listing status of directories
  " let g:fern_git_status#disable_directories = 1
'''

[[plugins]]
repo = 'lambdalisue/vim-protocol'

# [[plugins]]
# repo = 'justinmk/vim-dirvish'
# hook_add = '''
#   nmap <Plug>(nomap-dirvish_up) <Plug>(dirvish_up)
#
#   " need git support for 0
#   let g:dirvish_relative_paths = 1
#
#   augroup vimrc_init-dirvish
#     autocmd!
#
#     " re-map only dirvish
#     autocmd FileType dirvish nmap <silent><buffer>
#          \ - <Plug>(dirvish_up)
#
#     " Map `t` to open in new tab.
#     autocmd FileType dirvish
#          \  nnoremap <silent><buffer> t :call dirvish#open('tabedit', 0)<CR>
#          \ |xnoremap <silent><buffer> t :call dirvish#open('tabedit', 0)<CR>
#
#     " Map `gr` to reload.
#     autocmd FileType dirvish nnoremap <silent><buffer>
#          \ gr :<C-U>Dirvish %<CR>
#
#     " Map `gh` to hide dot-prefixed files.  Press `R` to "toggle" (reload).
#     autocmd FileType dirvish nnoremap <silent><buffer>
#          \ gh :silent keeppatterns g@\v/\.[^\/]+/?$@d _<cr>:setl cole=3<cr>
#   augroup END
# '''
# hook_post_source = '''
#   if has('gui_running')
#     call dirvish#add_icon_fn({p -> p[-1:]=='/'?'üìÇ':'üìÑ'})
#   endif
# '''

# Utils
##############
[[plugins]]
repo = 'rbtnn/vimconsole.vim'
# depends = ['vim-prettyprint'] # non-depend, but if already exist; use PrettyPrint

[[plugins]]
repo = 'thinca/vim-editvar'
# depends = ['vim-prettyprint'] # non-depend, but if already exist; use PrettyPrint

[[plugins]]
repo = 'lambdalisue/mr.vim'
depends = ['vim-altercmd']
hook_post_source = '''
  AlterCommand          mru Mru<Space><Bar><Space>copen
  AlterCommand <cmdwin> mru Mru<Space><Bar><Space>copen
  AlterCommand          mrw Mrw<Space><Bar><Space>copen
  AlterCommand <cmdwin> mrw Mrw<Space><Bar><Space>copen
'''

[[plugins]]
repo = 'Bakudankun/BackAndForward.vim'

[[plugins]]
repo = 'c000/rapidfire.vim'
hook_add = '''
  let g:rapidfire#persistent_filename = expand(g:user.dir.cache_home . '/rapidfire_commands.json')

  " need custom setting
  " like nnoremap <F12> :<C-u>Rapidfire F12<CR>
'''

[[plugins]]
repo = 'tsuyoshicho/vim-pass'
# rev  = 'develop'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['pass']

  if g:user.system.windows
    if !g:user.system.cygwin
      " Windows native not MSYS(cygwin) work
      " need native gpg (not /usr/bin/gpg)
      let s:gpg_32     = exepath('C:\Program Files (x86)\GnuPG\bin\gpg.exe')
      let s:gpg_native = exepath('C:\Program Files\GnuPG\bin\gpg.exe')

      if executable(s:gpg_32)
        let g:pass_gpg_path = s:gpg_32
      elseif executable(s:gpg_native)
        let g:pass_gpg_path = s:gpg_native
      endif
    endif
  endif
'''

[[plugins]]
repo = 'mattn/vim-findroot'
depends = ['vital.vim']
hook_add = '''
  let g:findroot_not_for_subdir = 0
'''
hook_post_source = '''
  let s:List     = g:V.import('Data.List')

  let g:findroot_patterns = s:List.concat([
    \ s:List.map(g:user.rootmarker.dirs, { v ->  v . '/' }),
    \ g:user.rootmarker.files,
    \ g:user.rootmarker.fileglob])
  unlet s:List

  augroup vimrc-init_findroot
    autocmd!
    autocmd User StartifyBufferOpened :FindRoot!
  augroup END
'''

# „Å™„Åè„Å¶„ÇÇ„Å°„ÇÉ„Çì„Å®Âãï„Åç„Åù„ÅÜ„Å™„ÅÆ„ÅßÁΩÆ„ÅÑ„Å¶„Åä„Åè
# [[plugins]]
# repo = 'airblade/vim-rooter'
# depends = ['vim-findroot']
# hook_add = '''
#   " manual support only
#   let g:rooter_manual_only = 1
#
#   " same as findroot
#   let g:rooter_use_lcd = 1
#   " manual only echo OK
#   " let g:rooter_silent_chdir = 1
#   let g:rooter_change_directory_for_non_project_files = 'current'
# '''
# hook_post_source = '''
#   let g:rooter_patterns = g:findroot_patterns
# '''

[[plugins]]
repo = 'thinca/vim-localrc'

[[plugins]]
repo = 'thinca/vim-singleton'
hook_source = '''
  " non-lazy„ÅÆ„Åü„ÇÅ„ÄÅ‰∏≠„Åß„ÉÅ„Çß„ÉÉ„ÇØ
  if has('clientserver')
    " non-lazy„ÅßsourceÂá¶ÁêÜÊôÇ„ÅØ„É≠„Éº„ÉâÊ∏à„Åø„ÇíÊ¥ªÁî®„Åô„Çã
    " singletonÂÆå‰∫ÜÂæÖ„Å°„É™„Çπ„Éà
    " git editmsg,rebase todo,rebase-xxx PRed
    " hub PRed
    let g:singleton#entrust_pattern['git'] =
      \ add(g:singleton#entrust_pattern['git'],
      \     '/\.git/EDIT_DESCRIPTION$')
    " singletonÈô§Â§ñ„É™„Çπ„Éà
    " let g:singleton#ignore_pattern

    " singletonÊ©üËÉΩ„ÇíÊúâÂäπ„Å´
    call singleton#enable()
    " debug
    " echom 'singleton enable' .' '. 'group:'.g:singleton#group .' '.  'servername:'.v:servername
  endif
'''

# Command
##############
[[plugins]]
repo = 'mattn/vim-sl'

[[plugins]]
repo = 'thinca/vim-ambicmd'
hook_post_source = '''
  cnoremap <expr> <Space> ambicmd#expand("\<Space>")
  cnoremap <expr> <CR>    ambicmd#expand("\<CR>")
'''

[[plugins]]
repo = 'gelguy/wilder.nvim'
hook_add = '''
'''
hook_post_source = '''
  " enable
  call wilder#enable_cmdline_enter()

  cnoremap <expr> <Tab>   wilder#in_context() ? wilder#next()     : "\<Tab>"
  cnoremap <expr> <S-Tab> wilder#in_context() ? wilder#previous() : "\<S-Tab>"

  " only / and ? is enabled by default
  call wilder#set_option('modes', ['/', '?'])
  " : is conflicted to wildmenu option longest:full,full
'''

# search
[[plugins]]
repo = 'osyo-manga/vim-over'
depends = ['vim-search-pulse']
hook_add = '''
  " currently search hl keep
  let g:over_enable_auto_nohlsearch = 0

  " first item jump
  let g:over#command_line#search#enable_move_cursor = 1

  let g:over_command_line_prompt = "Over> "

  let g:over#command_line#enable_Digraphs = 0

  " vim-search-pulse cr re-map and re-map stop
  let g:over_command_line_key_mappings = {
  \  "\<CR>" : {
  \    "key" : "\<CR>",
  \    "noremap" : 1,
  \  }
  \}

  augroup vimrc-init_over
    autocmd!
    " Pulses the first match after hitting the enter key
    autocmd User OverCmdLineExecute nested :call search_pulse#Pulse()
  augroup END
'''
hook_post_source = '''
  nnoremap <silent> <Leader>S :<C-u>OverCommandLine<cr>
'''

[[plugins]]
repo = 'inside/vim-search-pulse'
hook_add = '''
  let g:vim_search_pulse_disable_auto_mappings = 1
'''
hook_post_source = '''
  " color / termguicolors precheck need
  if has('gui_running') || (has('termguicolors') && (&termguicolors == 1))
    let g:vim_search_pulse_color_list = ['#005f00', '#008700', '#00af00', '#00d700', '#00ff00']
  else
    let g:vim_search_pulse_color_list = [22, 28, 34, 40, 46]
  endif

  " setup move to is.vim
'''

[[plugins]]
repo = 'lambdalisue/reword.vim'
depends = ['vim-altercmd', 'vim-over']
hook_add = '''
  " if dein#tap('vim-over')
  "   let g:reword_disable_seamless_preview = 1
  " endif
  " over not work normal built-in command (r,d,v and so on).
'''
hook_post_source = '''
  AlterCommand          rewo[rd] Reword
  AlterCommand <cmdwin> rewo[rd] Reword
'''

[[plugins]]
repo = 'haya14busa/vim-asterisk'
hook_add = '''
  let g:asterisk#keeppos = 1
'''
hook_post_source = '''
  " setup move to is.vim
'''

[[plugins]]
repo = 'osyo-manga/vim-anzu'
hook_post_source = '''
  " setup move to is.vim

  " update status
  augroup vimrc-init_anzu
    autocmd!
    autocmd CursorMoved,WinEnter * AnzuUpdateSearchStatus
  augroup END
'''

[[plugins]] # https://rcmdnk.com/blog/2017/11/12/computer-vim/
repo = 'haya14busa/is.vim'
depends = ['vim-asterisk', 'vim-anzu', 'vim-search-pulse']
hook_add = '''
  " let g:is#do_default_mappings = 0
'''
hook_post_source = '''
  " keymap : auto

  " based on https://postd.cc/vim-galore-4/
  " n„ÇíÂâçÊñπ„Å∏„ÄÅN„ÇíÂæåÊñπ„Å∏„Å®Âõ∫ÂÆö
  " integraton anzu
  map <expr> n v:searchforward ? '\<Plug>(is-nohl)\<Plug>(anzu-n-with-echo)\<Plug>Pulse' : '\<Plug>(is-nohl)\<Plug>(anzu-N-with-echo)\<Plug>Pulse'
  map <expr> N v:searchforward ? '\<Plug>(is-nohl)\<Plug>(anzu-N-with-echo)\<Plug>Pulse' : '\<Plug>(is-nohl)\<Plug>(anzu-n-with-echo)\<Plug>Pulse'

  " integration asterisk
  " stay only
  map *  <Plug>(asterisk-z*)<Plug>(is-nohl-1)<Plug>Pulse
  map g* <Plug>(asterisk-gz*)<Plug>(is-nohl-1)<Plug>Pulse
  map #  <Plug>(asterisk-z#)<Plug>(is-nohl-1)<Plug>Pulse
  map g# <Plug>(asterisk-gz#)<Plug>(is-nohl-1)<Plug>Pulse

  augroup vimrc-init_is
    autocmd!
    " Pulses the first match after hitting the enter key
    autocmd User IncSearchExecute nested :call search_pulse#Pulse()
  augroup END

  " Pulses cursor line on first match
  " when doing search with / or ?
  cmap <silent> <expr> <CR> search_pulse#PulseFirst()
  " conflict vim-over / mapping tuning in vim-over
'''

[[plugins]]
repo = 'tyru/vim-altercmd'

# [[plugins]]
# repo = 'c000/rapidfire.vim'

# Display
##############
[[plugins]]
repo = 'cohama/vim-insert-linenr'

[[plugins]]
repo = 'machakann/vim-highlightedyank'

[[plugins]]
repo = 'paroxayte/vwm.vim'

[[plugins]]
repo = 'blueyed/vim-diminactive'
hook_add = '''
  " if need update
  " let g:diminactive_buftype_blacklist = ['nofile', 'nowrite', 'acwrite', 'quickfix', 'help']
  " let g:diminactive_filetype_blacklist = ['startify']
  " Whitelist, overriding blacklist.
  " let g:diminactive_buftype_whitelist = []
  " let g:diminactive_filetype_whitelist = ['dirvish']

  " work with focus
  let g:diminactive_enable_focus = 1
'''

[[plugins]]
repo = 'kshenoy/vim-signature'
hook_add = '''
'''

[[plugins]]
repo = 'delphinus/vim-auto-cursorline'

[[plugins]]
repo = 'itchyny/vim-cursorword'

# Colortheme Util
##############
[[plugins]]
repo = 'vim-scripts/ScrollColors'
# repo = 'chumakd/ScrollColors'

[[plugins]] # color edit
repo = 'rbtnn/vim-coloredit'

[[plugins]] # „Ç´„É©„Éº„Çπ„Ç≠„Éº„Éû sample generator
repo = 'cocopon/colorswatch.vim'

[[plugins]] # „Ç´„É©„Éº„Çπ„Ç≠„Éº„Éû inspect
repo = 'cocopon/inspecthi.vim'

[[plugins]] # „Ç´„É©„Éº„Çπ„Ç≠„Éº„Éû template engine
repo = 'cocopon/pgmnt.vim'
depends = ['inspecthi.vim']

[[plugins]]
repo = 'lifepillar/vim-colortemplate'

[[plugins]]
repo = 'lambdalisue/vim-findent'

[[plugins]]
repo = 'rickhowe/diffchar.vim'
hook_add = '''
  " disable external diff
  let g:DiffExpr = 0
'''

[[plugins]]
repo = 'will133/vim-dirdiff'

# [[plugins]] # yank hist
# repo = 'LeafCage/yankround.vim'
# depends = ['ctrlp.vim', 'vital.vim']
# hook_add = '''
#   let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
#        \ + ['yankround']
#
#   let g:yankround_max_history = 40 " default 30
#   let g:yankround_use_region_hl = 1
#
#   " auto create dir in plugin
#   let g:yankround_dir = expand(g:user.dir.cache_home . '/yankround')
#   call g:user.function.mkdir(expand(g:yankround_dir))
# '''
# hook_post_source = '''
#   " keymap
#   nmap p <Plug>(yankround-p)
#   xmap p <Plug>(yankround-p)
#   nmap P <Plug>(yankround-P)
#   nmap gp <Plug>(yankround-gp)
#   xmap gp <Plug>(yankround-gp)
#   nmap gP <Plug>(yankround-gP)
#
#   if get(g:, 'ctrlp_map', '') ==? '<c-p>'
#     nmap <expr><C-p> yankround#is_active() ? "\<Plug>(yankround-prev)" : "\<Plug>(ctrlp)"
#   else
#     nmap <C-p> <Plug>(yankround-prev)
#   endif
#   nmap <C-n> <Plug>(yankround-next)
# '''

[[plugins]] # yank hist
repo = 'svermeulen/vim-yoink'
hook_add = '''
  let g:yoinkMaxItems = 20
'''
hook_post_source = '''
  " keymap
  nmap p <plug>(YoinkPaste_p)
  nmap P <plug>(YoinkPaste_P)

  nmap [y <plug>(YoinkRotateBack)
  nmap ]y <plug>(YoinkRotateForward)

  if get(g:, 'ctrlp_map', '') ==? '<c-p>'
    nmap <expr> <c-p> yoink#canSwap() ? '<plug>(YoinkPostPasteSwapForward)' : '<Plug>(ctrlp)'
  else
    nmap <c-p> <plug>(YoinkPostPasteSwapForward)
  endif
  nmap <c-n> <plug>(YoinkPostPasteSwapBack)

  nmap y <plug>(YoinkYankPreserveCursorPosition)
  xmap y <plug>(YoinkYankPreserveCursorPosition)
'''

# [[plugins]]
# repo = 'svermeulen/vim-cutlass'

[[plugins]]
repo = 'junegunn/vim-peekaboo'
hook_add = '''
  let g:peekaboo_window     = 'botright vsplit new'     " vert bo 30new  | Command for creating Peekaboo window
  let g:peekaboo_delay      = 0                         " 0 (ms)         | Delay opening of Peekaboo window
  let g:peekaboo_compact    = 1                         " 0 (boolean)    | Compact display
  let g:peekaboo_prefix     = '<Leader>'                " ''             | Prefix for key mapping (e.g. <leader>)
  let g:peekaboo_ins_prefix = '<C-y>'                   " ''             | Prefix for insert mode key mapping (e.g. <c-x>)
'''

[[plugins]]
repo = 'y0za/vim-reading-vimrc'
# repo = 'tsuyoshicho/vim-reading-vimrc'
# rev  = 'fix/urlredirect-20201004'

[[plugins]]
repo = 'thinca/vim-showtime'

# Quick Fix
[[plugins]]
repo = 'drmingdrmer/vim-toggle-quickfix'
hook_post_source = '''
  nmap <C-g><C-o> <Plug>window:quickfix:loop
  autocmd MyAutoGroup FileType qf nested nmap <buffer> q <Plug>window:quickfix:loop
'''

[[plugins]]
repo = 'itchyny/vim-qfedit'

[[plugins]]
repo = 'yssl/QFEnter'
hook_add = '''
  " ctrlp like
  let g:qfenter_keymap = {}
  let g:qfenter_keymap.open       = ['<CR>', '<2-LeftMouse>']
  let g:qfenter_keymap.vopen      = ['<C-v>']
  let g:qfenter_keymap.hopen      = ['<C-CR>', '<C-s>', '<C-x>']
  let g:qfenter_keymap.topen      = ['<C-t>']
  let g:qfenter_keymap.open_keep  = ['<Leader><CR>',  '<Leader><2-LeftMouse>']
  let g:qfenter_keymap.vopen_keep = ['<Leader><C-v>']
  let g:qfenter_keymap.hopen_keep = ['<Leader><C-CR>', '<Leader><C-s>', '<Leader><C-x>']
  let g:qfenter_keymap.topen_keep = ['<Leader><C-t>']
'''

# Session
# 'tpope/vim-obsession'
# 'dhruvasagar/vim-prosession'
# 'gikmx/vim-ctrlposession'

# Folding
[[plugins]] # folding support
repo = 'tyru/foldballoon.vim'
hook_post_source = '''
  " set global,default balloon expr / if specific use, override buffer local
  set ballooneval
  set balloonexpr=foldballoon#balloonexpr()
'''

[[plugins]] # folding support
repo = 'lambdalisue/vim-foldround'
hook_post_source = '''
  nmap <Leader>zff <Plug>(foldround-forward)
  nmap <Leader>zfb <Plug>(foldround-backward)
'''

[[plugins]] # folding support
repo = 'lambdalisue/readablefold.vim'
hook_post_source = '''
  autocmd MyAutoGroup FileType markdown nested setlocal foldtext=readablefold#foldtext()

  " generic folding setting start
  set foldcolumn=3
  set foldlevel=2
  " window local

  " set fillchars=vert:\|

  " highlight Folded gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey29 guifg=Grey80
  " highlight FoldColumn gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue

  " generic folding setting end
'''

# [[plugins]] # folding support
# repo = 'LeafCage/foldCC.vim'
# hook_post_source = '''
#   " based on http://leafcage.hateblo.jp/entry/2013/04/24/053113
#   let g:foldCCtext_enable_autofdc_adjuster = 1
#   " add Ôê≠ nf-oct-unfold / f42d
#   let g:foldCCtext_head = 'nr2char(0xf42d)." ".v:folddashes." "'
#
#   " need post_source for use defined function
#   set foldtext=FoldCCtext()
#   " overwrite markdown-ex foldtext function
#   autocmd MyAutoGroup FileType markdown nested setlocal foldtext=FoldCCtext()
#
#   " generic folding setting start
#   set foldcolumn=3
#   set foldlevel=2
#   " window local
#
#   " set fillchars=vert:\|
#
#   " highlight Folded gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey29 guifg=Grey80
#   " highlight FoldColumn gui=bold term=standout ctermbg=LightGrey ctermfg=DarkBlue guibg=Grey guifg=DarkBlue
#
#   " generic folding setting end
# '''

[[plugins]] # folding support
repo = 'arecarn/vim-fold-cycle'

# [[plugins]] # folding support
# repo = 'pseewald/vim-anyfold'

[[plugins]]
repo = 'mattn/wwwrenderer-vim'
depends = ['webapi-vim']

[[plugins]]
repo = 'thinca/vim-prettyprint'
hook_add = '''
  let g:prettyprint_string          = [ 'split', 'raw' ]
  let g:prettyprint_show_expression = 1
'''

[[plugins]]
repo = 's417-lama/carbonpaper.vim'

[[plugins]]
repo = 'kristijanhusak/vim-carbon-now-sh'
hook_post_source = '''
  vnoremap <silent> <F5> :CarbonNowSh<CR>
'''

[[plugins]]
repo = 'vim-jp/autofmt'
hook_add = '''
  " based on https://github.com/vim-jp/vimdoc-ja-working/issues/54#issuecomment-395459077
  " based on https://github.com/vim-jp/vimdoc-ja-working/wiki/Guide
  let g:autofmt_allow_over_tw=1

  set formatexpr=autofmt#japanese#formatexpr()

  " formatoptions already configured in vimrc (after load vimrc work)
  " set formatoptions+=mM or mB

  " smartindent already enable (after load vimrc work)
  " set smartindent

  set colorcolumn=+1
  " window local
'''

[[plugins]]
repo = 'mattn/emmet-vim'
hook_add = '''
  let g:user_emmet_mode = 'nv'
'''

[[plugins]]
# repo = 'tpope/vim-repeat'
repo = 'kana/vim-repeat'

[[plugins]]
repo = 'tpope/vim-unimpaired'
depends = ['vim-repeat']
hook_post_source = '''
  " nmap < [
  " nmap > ]
  " omap < [
  " omap > ]
  " xmap < [
  " xmap > ]
'''

[[plugins]]
repo = 'deton/jasentence.vim'
hook_add = '''
  " based on https://qiita.com/murashitas/items/f2be0dda2a4498cb7985
  let g:jasentence_endpat = '[„ÄÇÔºéÔºüÔºÅ]\+'
'''

[[plugins]]
repo = 'deton/jasegment.vim'
hook_add = '''
  let g:jasegment#mecab#cmd = 'mecab'
  let g:jasegment#cabocha#cmd = 'cabocha'

  let s:mecab_ok = 0
  let s:cabocha_ok = 0

  if g:user.system.windows
    let s:mecab_32     = exepath('C:\Program Files (x86)\MeCab\bin\mecab.exe')
    let s:mecab_native = exepath('C:\Program Files\MeCab\bin\mecab.exe')

    let s:mecab_cmd = ''
    if executable(s:mecab_32)
      let s:mecab_cmd = '"' . s:mecab_32 . '"'
    elseif executable(s:mecab_native)
      let s:mecab_cmd = '"' . s:mecab_native . '"'
    endif
    if !empty(s:mecab_cmd)
      let g:jasegment#mecab#cmd = s:mecab_cmd
      let s:mecab_ok = 1
      " echomsg 'windows mecab ok'
    endif

    let g:jasegment#cabocha#enc = 'cp932'

    let s:cabocha_32     = exepath('C:\Program Files (x86)\CaboCha\bin\cabocha.exe')
    let s:cabocha_native = exepath('C:\Program Files\CaboCha\bin\cabocha.exe')

    let s:cabocha_cmd = ''
    if executable(s:cabocha_32)
      let s:cabocha_cmd =  '"' . s:cabocha_32 . '"'
    elseif executable(s:mecab_native)
      let s:cabocha_cmd = '"' . s:cabocha_32 . '"'
    endif
    if !empty(s:cabocha_cmd)
      let g:jasegment#cabocha#cmd = s:cabocha_cmd
      let s:cabocha_ok = 1
      " echomsg 'windows cabocha ok'
    endif
  else
    " non-windows
    " if MeCab exists, change model default to mecab
    let s:mecab_ok = executable(g:jasegment#mecab#cmd)
    " if CaboCha exists, change model default to cabocha
    let s:cabocha_ok = executable(g:jasegment#cabocha#cmd)
  endif

  " if MeCab exists, change model default to mecab
  if s:mecab_ok
    let g:jasegment#model = 'mecab'
    " if CaboCha exists, change model default to cabocha
    if s:cabocha_ok
      let g:jasegment#model = 'cabocha'
    endif
    let g:jasegment#model_word = g:jasegment#model
    " echomsg 'model     :' . g:jasegment#model
    " echomsg 'model word:' . g:jasegment#model_word
  endif

  let g:jasegment#highlight = 1
'''

# Split/Join
[[plugins]]
repo = 'AndrewRadev/splitjoin.vim'
depends = ['tabular']
hook_add = '''
  let g:splitjoin_align = 1
  let g:splitjoin_trailing_comma = 1
  let g:splitjoin_ruby_trailing_comma = 1
  let g:splitjoin_ruby_curly_braces = 0
  let g:splitjoin_ruby_hanging_args = 0
'''

[[plugins]]
repo = 'osyo-manga/vim-jplus'
hook_add = '''
  " J „ÅÆÊåôÂãï„Çí jplus.vim „ÅßË°å„ÅÜ
  nmap J <Plug>(jplus)
  vmap J <Plug>(jplus)

  " getchar() „Çí‰ΩøÁî®„Åó„Å¶ÊåøÂÖ•ÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„Åæ„Åô
  nmap <Leader>J <Plug>(jplus-getchar)
  vmap <Leader>J <Plug>(jplus-getchar)

  " input„ÅßË§áÊï∞
  nmap <Leader>gJ <Plug>(jplus-input)
  vmap <Leader>gJ <Plug>(jplus-input)

  " let g:jplus#config = {}

  let g:jplus#input_config = {
        \ '__DEFAULT__' : {
        \  'delimiter_format' : '%d ',
        \ },
        \ '__EMPTY__'   : {
        \  'delimiter'        : ' ',
        \  'delimiter_format' : '%d',
        \ },
        \ '+' : {
        \  'delimiter_format' : ' %d '
        \ },
        \ '.' : {
        \  'delimiter_format' : '%d'
        \ },
        \ '_' : {
        \  'delimiter_format' : '%d'
        \ },
        \ '->' : {
        \  'delimiter_format' : '%d'
        \ },
        \ '/' : {
        \  'delimiter_format' : '%d'
        \ },
        \ ':' : {
        \  'delimiter_format' : '%d'
        \ },
        \}
'''

# File Header
[[plugins]]
repo = 'ahonn/vim-fileheader'
hook_add = '''
  " let g:fileheader_auto_add = 0    " Default value: 0
  " let g:fileheader_auto_update = 1 " Default value: 1

  " let g:fileheader_by_git_config = 1 " Default value: 1
  let g:fileheader_author = g:user.git.name
  let g:fileheader_email  = g:user.git.email
  let g:fileheader_date_format = '%Y-%m-%d %H:%M:%S'
'''
hook_post_source = '''
  " simple delay (git user/email async get in fileheader plugin)
  " restore back from git setting in fileheader plugin
  let g:user.git.name  = g:fileheader_author
  let g:user.git.email = g:fileheader_email

  " set as default
  let g:fileheader_author = g:user.name
  let g:fileheader_email  = g:user.email

  let s:c_style = { 'begin': '/**', 'char': ' * ', 'end': ' */' }
  let g:fileheader_delimiter_map = {
        \ 'c'    : s:c_style,
        \ 'cpp'  : s:c_style,
        \ 'java' : s:c_style,
        \}
'''

[[plugins]]
repo = 'alpertuna/vim-header'
depends = ['vim-fileheader'] # use setting
hook_add = '''
  let g:header_auto_add_header = 0
'''
hook_post_source = '''
  let g:header_alignment = 0
  let g:header_max_size = 10

  let g:header_field_filename = 1
  " let g:header_field_filename_path = 0

  " set as default
  let g:header_field_author        = g:user.name
  let g:header_field_author_email  = g:user.email

  " simple delay (git user/email async get in fileheader plugin)

  let g:header_field_timestamp_format = g:fileheader_date_format

  " let g:header_field_copyright = ''
  " let g:header_field_timestamp = 1
  " let g:header_field_modified_timestamp = 1
  " let g:header_field_modified_by = 1

  " let g:header_field_timestamp_format = '...'

  " let g:header_field_license_id = ''

  " let g:header_cfg_comment_char = '#'
'''

[[plugins]]
# repo = 'syngan/vim-clurin'
repo = 'uplus/vim-clurin'
depends = ['vim-speeddating']
hook_add = '''
  " original syngan use_default define top(all lang)
  " modified uplus  use_default define per-lang

  " see https://bitbucket.org/hokorobi/vimfiles_pub/src
  " see https://github.com/syngan/vim-clurin
  function! s:ctrl_a_x(cnt) abort
    " normal op
    " if a:cnt >= 0
    "     execute 'normal!' a:cnt . "\<C-A>"
    " else
    "     execute 'normal!' (-a:cnt) . "\<C-X>"
    " endif

    " " speeddaging
    " call speeddating#increment(a:cnt)

    " hokorobi san model
    if a:cnt < 0
      call speeddating#increment(-v:count1)
    else
      call speeddating#increment(v:count1)
    endif
  endfunction

  let g:clurin = {
        \ '-': {
        \   'use_default': 0,
        \   'nomatch': function('s:ctrl_a_x'),
        \   'def': [
        \      ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        \      ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        \      ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        \      ['true', 'false'],
        \      ['True', 'False'],
        \      ['TRUE', 'FALSE'],
        \      ['on', 'off'],
        \      ['On', 'Off'],
        \      ['ON', 'OFF'],
        \      ['yes', 'no'],
        \      ['Yes', 'No'],
        \      ['YES', 'NO'],
        \      ['enable', 'disable'],
        \      ['Enable', 'Disable'],
        \      ['ENABLE', 'DISABLE'],
        \      ['left', 'right'],
        \      ['Left', 'Right'],
        \      ['LEFT', 'RIGHT'],
        \      ['min', 'max'],
        \      ['Min', 'Max'],
        \      ['MIN', 'MAX'],
        \      ['=', ' = '],
        \      ['+', ' + '],
        \      ['-', ' - '],
        \      ['*', ' * '],
        \      ['/', ' / '],
        \      ['%', ' % '],
        \      ['‚ñ°', '‚ñ†', '‚òëÔ∏è', '‚òí'] ,
        \      ['‚òÜ', '‚òÖ'] ,
        \      [
        \        {'pattern': 'Êúà\(\%[ÊõúÊó•]\)', 'replace': 'Êúà\1'},
        \        {'pattern': 'ÁÅ´\(\%[ÊõúÊó•]\)', 'replace': 'ÁÅ´\1'},
        \        {'pattern': 'Ê∞¥\(\%[ÊõúÊó•]\)', 'replace': 'Ê∞¥\1'},
        \        {'pattern': 'Êú®\(\%[ÊõúÊó•]\)', 'replace': 'Êú®\1'},
        \        {'pattern': 'Èáë\(\%[ÊõúÊó•]\)', 'replace': 'Èáë\1'},
        \        {'pattern': 'Âúü\(\%[ÊõúÊó•]\)', 'replace': 'Âúü\1'},
        \        {'pattern': 'Êó•\(\%[ÊõúÊó•]\)', 'replace': 'Êó•\1'},
        \      ],
        \   ]
        \ },
        \ 'toml vim': {
        \   'def': [
        \      [
        \        {'pattern': '"' . '\([^"]*\)'  . '"' , 'replace': '"' . '\1' . '"'},
        \        {'pattern': "'" . '\([^'']*\)' . "'" , 'replace': "'" . '\1' . "'"},
        \      ]
        \   ]
        \ },
        \ 'vim': {
        \   'def': [
        \      [
        \        {'pattern': '\[''\(\k\+\)''\]', 'replace': '[''\1'']'},
        \        {'pattern': '\["\(\k\+\)"\]'  , 'replace': '["\1"]'},
        \        {'pattern': '\.\(\k\+\)'      , 'replace': '.\1'},
        \      ]
        \   ]
        \ },
        \ 'markdown': {
        \   'def': [
        \      ['[ ]', '[x]'],
        \   ]
        \ },
        \ 'gitrebase': {
        \   'def': [
        \      ['pick', 'fixup', 'reword', 'edit', 'squash', 'drop', 'exec'],
        \   ]
        \ },
        \ 'c cpp' : {
        \   'def': [
        \     [ '&&', '||' ],
        \     [
        \       {'pattern': '\(\k\+\)\.', 'replace': '\1.'},
        \       {'pattern': '\(\k\+\)->', 'replace': '\1->'},
        \     ]
        \   ]
        \ }
        \}
'''
hook_post_source = '''
  nmap + <Plug>(clurin-next)
  nmap - <Plug>(clurin-prev)
  vmap + <Plug>(clurin-next)
  vmap - <Plug>(clurin-prev)
'''

[[plugins]]
# repo = 'kamykn/spelunker.vim'
repo = 'tsuyoshicho/spelunker.vim'
rev  = 'feature/ctlp-improve'
depends = ['ctrlp.vim']
hook_add = '''
  " ctrlp ext
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['spelunker']

  " Enable spelunker.vim. (default: 1)
  " 1: enable
  " 0: disable
  " let g:enable_spelunker_vim = 1

  " Enable spelunker.vim on readonly files or buffer. (default: 0)
  " 1: enable
  " 0: disable
  " let g:enable_spelunker_vim_on_readonly = 0

  " Check spelling for words longer than set characters. (default: 4)
  " let g:spelunker_target_min_char_len = 4

  " Option to disable word checking.
  " Disable URI checking. (default: 0)
  " let g:spelunker_disable_uri_checking = 1

  " Disable email-like words checking. (default: 0)
  " let g:spelunker_disable_email_checking = 1

  " Disable account name checking, e.g. @foobar, foobar@. (default: 0)
  " NOTE: Spell checking is also disabled for JAVA annotations.
  " let g:spelunker_disable_account_name_checking = 1

  " Disable acronym checking. (default: 0)
  " let g:spelunker_disable_acronym_checking = 1

  " Disable checking words in backtick/backquote. (default: 0)
  " let g:spelunker_disable_backquoted_checking = 1

  " Max amount of word suggestions. (default: 15)
  autocmd MyAutoGroup VimEnter,VimResized * let g:spelunker_max_suggest_words = min([(&lines/4), 10]) - 1

  " Max amount of highlighted words in buffer. (default: 100)
  " let g:spelunker_max_hi_words_each_buf = 100

  " Spellcheck type: (default: 1)
  " 1: File is checked for spelling mistakes when opening and saving. This
  " may take a bit of time on large files.
  " 2: Spellcheck displayed words in buffer. Fast and dynamic. The waiting time
  " depends on the setting of CursorHold `set updatetime=1000`.
  let g:spelunker_check_type = 2

  " Highlight type: (default: 1)
  " 1: Highlight all types (SpellBad, SpellCap, SpellRare, SpellLocal).
  " 2: Highlight only SpellBad.
  " FYI: https://vim-jp.org/vimdoc-en/spell.html#spell-quickstart
  " let g:spelunker_highlight_type = 1

  " Disable default autogroup. (default: 0)
  " let g:spelunker_disable_auto_group = 1

  " Create own custom autogroup to enable spelunker.vim for specific filetypes.

  " autocmd MyAutoGroup Filetype startify
  "      \ if g:enable_spelunker_vim  | call spelunker#toggle() | endif

  " Override highlight group name of incorrectly spelled words. (default:
  " 'SpelunkerSpellBad')
  " let g:spelunker_spell_bad_group = 'SpelunkerSpellBad'

  " Override highlight group name of complex or compound words. (default:
  " 'SpelunkerComplexOrCompoundWord')
  " let g:spelunker_complex_or_compound_word_group = 'SpelunkerComplexOrCompoundWord'

  " skip word
  let g:spelunker_white_list_for_user = ['tsuyoshi_cho']
'''
hook_post_source = '''
  set nospell
  set complete-=kspell

  " jump keymap
  silent! nmap <unique> ]s <Plug>(spelunker-jump-next)
  silent! nmap <unique> [s <Plug>(spelunker-jump-prev)
'''

# [[plugins]] # codic support
# repo = 'koron/codic-vim'

[[plugins]] # codic support
repo = 'tsuyoshicho/codic-web.vim'
rev  = 'develop'
depends = ['vim-pass']
hook_add = '''
  " let g:codicweb_token = '<token>'
  call pass#get_startup('g:codicweb_token','Develop/Codic')
'''

[[plugins]]
repo = 'tpope/vim-speeddating'
depends = ['vim-repeat']
hook_add = '''
  " let g:speeddating_no_mappings = 1 " if conflict

  " remove windows setting
  if g:user.system.windows
    silent! vunmap <C-X>
  endif
'''
hook_post_source = '''
  " nmap  <C-A> <Plug>SpeedDatingUp
  " nmap  <C-X> <Plug>SpeedDatingDown
  " xmap  <C-A> <Plug>SpeedDatingUp
  " xmap  <C-X> <Plug>SpeedDatingDown
  " nmap d<C-A> <Plug>SpeedDatingNowUTC
  " nmap d<C-X> <Plug>SpeedDatingNowLocal

  " format add
  SpeedDatingFormat %Y%[/-]%-m%1%-d %_H:%M       " 2000/1/1 10:15
  SpeedDatingFormat %Y%[/-]%-m%1%-d              " 2000/1/1
  SpeedDatingFormat %H:%0M                       " 10:15
  SpeedDatingFormat %YÂπ¥%-mÊúà%-dÊó•%?[ ]%_HÊôÇ%MÂàÜ " 2000Âπ¥1Êúà1Êó• 12ÊôÇ1ÂàÜ
  SpeedDatingFormat %YÂπ¥%-mÊúà%-dÊó•               " 2000Âπ¥1Êúà1Êó•
  " SpeedDatingFormat %-mÊúà%-dÊó•%?[ ](%a)         " 1Êúà1Êó• (Êúà)
  SpeedDatingFormat %-mÊúà%-dÊó•                   " 1Êúà1Êó•
  SpeedDatingFormat %HÊôÇ%0MÂàÜ%SÁßí                " 12ÊôÇ1ÂàÜ30Áßí
  SpeedDatingFormat %HÊôÇ%MÂàÜ                     " 12ÊôÇ1ÂàÜ
  SpeedDatingFormat %MÂàÜ%SÁßí                     " 1ÂàÜ30Áßí
'''

[[plugins]] # https://pixe.la/
repo = 'mattn/vim-pixela'
# on_if= 'executable("curl")' # check inner and load at start needed
depends = ['open-browser.vim','vim-pass']
hook_add = '''
  " let g:pixela_username = 'tsuyoshicho'
  " let g:pixela_token    = '<token>'

  call pass#get_startup('g:pixela_username','Develop/Pixela','username')
  call pass#get_startup('g:pixela_token','Develop/Pixela')
'''

## textobj & operator
# textobj
# see http://d.hatena.ne.jp/osyo-manga/20130717/1374069987
# support tool
# need more good config, temp off
# [[plugins]]
# repo = 'terryma/vim-expand-region'
# hook_add = '''
#   " set use textobj keymap
#   " let g:expand_region_text_objects = {
#   " need config
#   "   \}
#   " and other config for custom textobj
# '''
# hook_post_source = '''
#   " conflict vim built-in v/C-V operation(switch normal/visual-submode)
#   " vmap v     <Plug>(expand_region_expand)
#   " vmap <C-v> <Plug>(expand_region_shrink)
#   " do not work
#   " vmap w     <Plug>(expand_region_expand)
#   " omap w     <Plug>(expand_region_expand)
#   " vmap n     <Plug>(expand_region_shrink)
#   " omap n     <Plug>(expand_region_shrink)
# '''

# textobj „ÅÆ„Éô„Éº„Çπ
[[plugins]]
repo = 'kana/vim-textobj-user'

# special
# Ë§áÊï∞„ÅÆ„Ç´„ÉÉ„Ç≥„ÅßÂá¶ÁêÜ„ÇíÂÆüÊñΩ„Åó„ÄÅ„Éû„ÉÉ„ÉÅ„Åó„Åü„ÇÇ„ÅÆor(list„Å™„Çâ)‰∏ÄÁï™ÂÜÖÂÅ¥„Çí‰Ωø„ÅÜ
# amb, imb
[[plugins]]
repo = 'osyo-manga/vim-textobj-multiblock'
depends = ['vim-textobj-user']
hook_add = '''
  " see https://github.com/rinx/dotfiles/blob/master/vimrc
  " tex
  function s:multiblock_hook_add_tex()
    let b:textobj_multiblock_blocks = [
          \ ['\$', '\$', 1],
          \ ['\$\$', '\$\$', 1],
          \ ]
  endfunction

  " markdown
  function s:multiblock_hook_add_markdown()
    let b:textobj_multiblock_blocks = [
          \ ['`', '`', 1],
          \ ['```', '```'],
          \ ]
  endfunction

  " ruby
  function s:multiblock_hook_add_ruby()
    let b:textobj_multiblock_blocks = [
          \ ['/', '/', 1],
          \ ]
  endfunction

  augroup vimrc-init_multiblock_hook_add
    autocmd!
    autocmd FileType tex,latex,plaintex nested call <SID>multiblock_hook_add_tex()
    autocmd FileType markdown           nested call <SID>multiblock_hook_add_markdown()
    autocmd FileType ruby               nested call <SID>multiblock_hook_add_ruby()
  augroup END
'''
hook_post_source = '''
  omap amb <Plug>(textobj-multiblock-a)
  omap imb <Plug>(textobj-multiblock-i)
  vmap amb <Plug>(textobj-multiblock-a)
  vmap imb <Plug>(textobj-multiblock-i)
'''

# „Ç´„ÉÉ„Ç≥Á≥ª„ÅßË§áÊï∞„ÅÆÂá¶ÁêÜ„ÇíÂÆüÊñΩ„Åó„ÄÅ„Éû„ÉÉ„ÉÅ„Åó„Åü„ÇÇ„ÅÆor(list„Å™„Çâ)‰∏ÄÁï™ÂÜÖÂÅ¥„Çí‰Ωø„ÅÜ
# amt, imt
[[plugins]]
repo = 'osyo-manga/vim-textobj-multitextobj'
depends = ['vim-textobj-user', 'vim-textobj-url', 'vim-sandwich', 'vim-textobj-multiblock', 'vim-textobj-function', 'vim-textobj-jabraces']
hook_add = '''
  " URL,datetime,paren,function,space,wiw,indent
  " paren replace vim-sandwich autofunction
  let g:textobj_multitextobj_textobjects_i = [
        \   '<Plug>(textobj-url-i)',
        \   '<Plug>(textobj-sandwich-auto-i)',
        \   '<Plug>(textobj-multiblock-i)',
        \   '<Plug>(textobj-function-i)',
        \]

  let g:textobj_multitextobj_textobjects_a = [
        \   '<Plug>(textobj-url-a)',
        \   '<Plug>(textobj-sandwich-auto-a)',
        \   '<Plug>(textobj-multiblock-i)',
        \   '<Plug>(textobj-function-a)',
        \]

  " jabraces
  " ÔºàÔºâ    <Plug>(textobj-jabraces-parens-i)
  " ÔºªÔºΩ    <Plug>(textobj-jabraces-braces-i)
  " ÔΩõÔΩù    <Plug>(textobj-jabraces-brackets-i)
  " ÔºúÔºû    <Plug>(textobj-jabraces-angles-i)
  " ‚â™‚â´    <Plug>(textobj-jabraces-double-angles-i)
  " „Äå„Äç    <Plug>(textobj-jabraces-kakko-i)
  " „Äé„Äè    <Plug>(textobj-jabraces-double-kakko-i)
  " „Äà„Äâ    <Plug>(textobj-jabraces-yama-kakko-i)
  " „Ää„Äã    <Plug>(textobj-jabraces-double-yama-kakko-i)
  " „Äî„Äï    <Plug>(textobj-jabraces-kikkou-kakko-i)
  " „Äê„Äë    <Plug>(textobj-jabraces-sumi-kakko-i)
  let g:textobj_multitextobj_textobjects_group_i = {}
  let g:textobj_multitextobj_textobjects_group_i.A = [
        \ '<Plug>(textobj-jabraces-kakko-i)',
        \ '<Plug>(textobj-jabraces-double-kakko-i)',
        \ '<Plug>(textobj-jabraces-double-yama-kakko-i)',
        \ '<Plug>(textobj-jabraces-sumi-kakko-i)',
        \ '<Plug>(textobj-jabraces-double-angles-i)',
        \ '<Plug>(textobj-jabraces-parens-i)',
        \ '<Plug>(textobj-jabraces-braces-i)',
        \ '<Plug>(textobj-jabraces-brackets-i)',
        \ ]
  let g:textobj_multitextobj_textobjects_group_a = {}
  let g:textobj_multitextobj_textobjects_group_a.A = [
        \ '<Plug>(textobj-jabraces-kakko-a)',
        \ '<Plug>(textobj-jabraces-double-kakko-a)',
        \ '<Plug>(textobj-jabraces-double-yama-kakko-a)',
        \ '<Plug>(textobj-jabraces-sumi-kakko-a)',
        \ '<Plug>(textobj-jabraces-double-angles-a)',
        \ '<Plug>(textobj-jabraces-parens-a)',
        \ '<Plug>(textobj-jabraces-braces-a)',
        \ '<Plug>(textobj-jabraces-brackets-a)',
        \ ]
  map <Plug>(textobj-multitextobj-jabraces-i) <Plug>(textobj-multitextobj-A-i)
  map <Plug>(textobj-multitextobj-jabraces-a) <Plug>(textobj-multitextobj-A-a)
'''
hook_post_source = '''
  omap imt <Plug>(textobj-multitextobj-i)
  omap amt <Plug>(textobj-multitextobj-a)
  vmap imt <Plug>(textobj-multitextobj-i)
  vmap amt <Plug>(textobj-multitextobj-a)

  omap amj <Plug>(textobj-multitextobj-jabraces-a)
  omap imj <Plug>(textobj-multitextobj-jabraces-i)
  vmap amj <Plug>(textobj-multitextobj-jabraces-a)
  vmap imj <Plug>(textobj-multitextobj-jabraces-i)
'''

# „Éê„ÉÉ„Éï„Ç°ÂÖ®‰Ωì
# ae, ie
# subversive„Å®ÈÄ£Êê∫„Åó„Å¶„Éê„ÉÉ„Éï„Ç°ÂÖ®‰Ωì„ÇíÁΩÆÊèõ„Å™„Å©„Åô„Çã
[[plugins]]
repo = 'kana/vim-textobj-entire'
depends = ['vim-textobj-user']

# Ë°åÂçò‰Ωç
# al, il
[[plugins]]
repo = 'kana/vim-textobj-line'
depends = 'vim-textobj-user'

# FoldingÂçò‰Ωç
# az, iz
[[plugins]]
repo = 'kana/vim-textobj-fold'
depends = 'vim-textobj-user'

# Êåü„Åæ„Çå„ÅüÂçòË™û(ÊåáÂÆö„ÅÆÁõ¥Âæå„ÅÆÊñáÂ≠ó„ÅßÂõ≤„Åæ„Çå„Å¶„Çã„Å®Âà§Êñ≠„Åô„Çã)
# a/<char>, i/<char>
[[plugins]]
repo = 'thinca/vim-textobj-between'
depends = 'vim-textobj-user'
hook_add = '''
  let g:textobj_between_no_default_key_mappings = 1
'''
hook_post_source = '''
  omap i/ <Plug>(textobj-between-i)
  xmap i/ <Plug>(textobj-between-i)
  omap a/ <Plug>(textobj-between-a)
  xmap a/ <Plug>(textobj-between-a)
'''

# Êó•‰ªò„Å®ÊôÇÂàª
# ada, ida (auto)
[[plugins]]
repo = 'kana/vim-textobj-datetime'
depends = ['vim-textobj-user']

# ÈÄ£Á∂ö„Åó„Åü„Çπ„Éö„Éº„Çπ
# aS, iS
[[plugins]]
repo = 'saihoooooooo/vim-textobj-space'
depends = ['vim-textobj-user']

# Êó•Êú¨Ë™ûÊã¨Âºß
# „Éá„Éï„Ç©„É´„Éàoff
[[plugins]]
repo = 'kana/vim-textobj-jabraces'
hook_add = '''
  let g:textobj_jabraces_no_default_key_mappings = 1
'''

# Èñ¢Êï∞ÂÜÖ
# af, if
# # af, if -> aF, iF„Å´„Éû„ÉÉ„Éó (between„Å®„Éê„ÉÉ„ÉÜ„Ç£„É≥„Ç∞)
# # aF, iF„ÅØ‰Ωø„Çè„Å™„ÅÑ
# „Éá„Éï„Ç©„É´„Éàoff
[[plugins]]
# repo = 'kana/vim-textobj-function'
repo = 'tsuyoshicho/vim-textobj-function'
rev  = 'develop'
depends = ['vim-textobj-user']
hook_add = '''
  " let g:textobj_function_no_default_key_mappings = 1
'''
hook_post_source = '''
  " omap iF <Plug>(textobj-function-i)
  " omap aF <Plug>(textobj-function-a)
  " vmap iF <Plug>(textobj-function-i)
  " vmap aF <Plug>(textobj-function-a)
'''

# Èñ¢Êï∞ÂÜÖ
# syntax„ÇíÂà©Áî®„Åô„Çã function Êã°Âºµ
[[plugins]]
repo = 'haya14busa/vim-textobj-function-syntax'
depends = ['vim-textobj-function']

# „Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ„Å®Âêå„Åò„Ç§„É≥„Éá„É≥„Éà
# ai, ii / aI, iI
[[plugins]]
repo = 'kana/vim-textobj-indent'
depends = ['vim-textobj-user']

# URLÈÅ∏Êäû
# au, iu
[[plugins]]
repo = 'mattn/vim-textobj-url'
depends = ['vim-textobj-user']

# Ë®ÄË™ûÂà•
# multi„Å´ÂÖ•„Çå„Å™„ÅÑÁ≥ª
# word „ÅÆ‰∏≠„ÅÆÂçòË™û„ÇíÈÅ∏Êäû
# a<prefix>w, i<prefix>w
# prefix = ,w ÁßªÂãïÊ©üËÉΩ„ÇÇ„ÅÇ„Çã
[[plugins]]
repo = 'h1mesuke/textobj-wiw'
depends = ['vim-textobj-user']
hook_add = '''
  let g:textobj_wiw_default_key_mappings_prefix = ',w'
'''

# contextÂÜÖ
# icx
# at vim-precious

# „Éñ„É≠„ÉÉ„ÇØÂÜÖ/paren„Åî„Å®
# a%, i%
# at vim-matchup

# swapÂèØËÉΩ„Å™„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà(ÂºïÊï∞„ÇÑÈÖçÂàó„É°„É≥„Éê„Å™„Å©„ÅÆ,Âå∫Âàá„Çä„Éá„Éº„Çø)
# a,, i,,
# at vim-swap

# operator
# see https://qiita.com/rbtnn/items/a47ed6684f1f0bc52906
# ToDo Keymap list up and setup
[[plugins]]
repo = 'kana/vim-operator-user'

# ÈÄ£Áï™‰ªò‰∏é
# operator:viw„Å™„Å© ÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Å¶zS(normal)/zP(prev)„ÅßÂá¶ÁêÜ
[[plugins]]
repo = 'deris/vim-rengbang'
# repo = 'tsuyoshicho/vim-rengbang'
# rev  = 'develop'
depends = ['vim-operator-user']
hook_post_source = '''
  " xmap
  " <Plug>(operator-rengbang)
  " <Plug>(operator-rengbang-useprev)
  "
  " You can use following operator.

  " This operator like :'<,'>RengBang (use default options).
  map zS <Plug>(operator-rengbang)
  " This operator like :'<,'>RengBangUsePrev (use previous options).
  map zP <Plug>(operator-rengbang-useprev)

  " see https://vim-jp.org/blog/2015/06/30/visual-ctrl-a-ctrl-x.html
  " visual ctrl-x/ctrl-a
  " vnoremap <c-a> <c-a>gv
  " vnoremap <c-x> <c-x>gv
  " use speeddating if

  " g<C-A> „Å® g<C-X> „Çí‰Ωø„ÅÜ‰∫ã„ÅßÁ∞°Âçò„Å´ÈÄ£Áï™„Çí‰ªò‰∏é„Åô„Çã‰∫ã„ÅåÂá∫Êù•„Çã
'''

# „Ç≥„É°„É≥„Éà„Éà„Ç∞„É´
# operator:viw„Å™„Å© ÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Å¶gcc„ÅßÂá¶ÁêÜ
#  'tyru/caw.vim'

# operator:viw„Å™„Å© ÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Å¶sa/sd/sr+<char>„ÅßÂá¶ÁêÜ
# textobj :as, is (Ëá™Âãï)/ ab, ib (Á∂ö„Åë„Å¶Âå∫Âàá„ÇäÊñáÂ≠ó„ÇíÂÖ•Âäõ)
[[plugins]]
repo = 'machakann/vim-sandwich'
hook_add = '''
  let g:sandwich#recipes = deepcopy(g:sandwich#default_recipes)
  let g:sandwich#recipes += [
    \ {
    \   'buns': ['#{', '}'],
    \   'input': ['#'],
    \   'filetype': ['vim'],
    \   'nesting': 1,
    \ },
    \ {
    \   'buns': ['\(', '\)'],
    \   'input': ['8'],
    \   'filetype': ['vim'],
    \   'nesting': 1,
    \ },
    \ {
    \   'buns': ['\%(', '\)'],
    \   'input': ['%'],
    \   'filetype': ['vim'],
    \   'nesting': 1,
    \ },
    \ {
    \   'buns': ['\<', '\>'],
    \   'input': [','],
    \   'filetype': ['vim'],
    \   'nesting': 0,
    \ },
    \ {
    \   'buns': ['$(', ')'],
    \   'input': ['$'],
    \   'filetype': ['sh'],
    \   'nesting': 1,
    \ },
    \ {'buns' : ['Ôºà', 'Ôºâ']},
    \ {'buns' : ['Ôºª', 'ÔºΩ']},
    \ {'buns' : ['ÔΩõ', 'ÔΩù']},
    \ {'buns' : ['Ôºú', 'Ôºû']},
    \ {'buns' : ['‚â™', '‚â´']},
    \ {'buns' : ['„Äå', '„Äç']},
    \ {'buns' : ['„Äé', '„Äè']},
    \ {'buns' : ['„Äà', '„Äâ']},
    \ {'buns' : ['„Ää', '„Äã']},
    \ {'buns' : ['„Äî', '„Äï']},
    \ {'buns' : ['„Äê', '„Äë']},
    \]

  let g:sandwich#magicchar#f#patterns = deepcopy(g:sandwich#magicchar#f#default_patterns)
  let g:sandwich#magicchar#f#patterns += [
    \ {
    \   'header' : '\<\h\k*', 'footer' : '',
    \   'bra'    : '(',       'ket'    : ')',
    \ },
    \]
'''
hook_post_source = '''
  omap as <Plug>(textobj-sandwich-auto-a)
  omap is <Plug>(textobj-sandwich-auto-i)
  vmap as <Plug>(textobj-sandwich-auto-a)
  vmap is <Plug>(textobj-sandwich-auto-i)
'''

# viw„Å™„Å© ÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Å¶<c-g>q„ÅßÂá¶ÁêÜ Âº∑Âà∂ÊîπË°å
[[plugins]]  # like gq operator
repo = 'lambdalisue/vim-operator-breakline'
depends = ['vim-operator-user']
hook_add = '''
  " The following mappings use the value of 'textwidth'
  nmap <C-g>q <Plug>(operator-breakline-textwidth)
  xmap <C-g>q <Plug>(operator-breakline-textwidth)

  " The following mappings shows prompt to ask the value
  nmap <C-g>Q <Plug>(operator-breakline-manual)
  xmap <C-g>Q <Plug>(operator-breakline-manual)
'''

# viw„Å™„Å© ÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Å¶zr„ÅßÂá¶ÁêÜ yank„Å®ÂÖ•„ÇåÊõø„Åà
[[plugins]]  # yank replace operator
repo = 'kana/vim-operator-replace'
depends = ['vim-operator-user']
hook_add = '''
  map zr <Plug>(operator-replace)
'''

[[plugins]] # replace operator
repo = 'svermeulen/vim-subversive'
depends = ['vim-yoink']
hook_post_source = '''
  nmap <leader>s <plug>(SubversiveSubstituteRange)
  xmap <leader>s <plug>(SubversiveSubstituteRange)

  nmap <leader>ss <plug>(SubversiveSubstituteWordRange)

  " abolish integ
  " nmap <leader><leader>s <plug>(SubversiveSubvertRange)
  " xmap <leader><leader>s <plug>(SubversiveSubvertRange)
  "
  " nmap <leader><leader>ss <plug>(SubversiveSubvertWordRange)

  " need yoink
  xmap s <plug>(SubversiveSubstitute)
  xmap p <plug>(SubversiveSubstitute)
  xmap P <plug>(SubversiveSubstitute)
'''

# cx<obj> „ÅÆ„ÅÆ„Å° cx<obj>„ÅßÂÖ•„ÇåÊõø„Åà
# cxx „ÅØ„É©„Ç§„É≥Âõ∫ÂÆö
# cxc „ÅØÁä∂ÊÖã„ÇØ„É™„Ç¢
# X in Visual„ÇÇÂÖ•„ÇåÊõø„Åà
[[plugins]]
repo = 'tommcdo/vim-exchange'

# viw„Å™„Å© ÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Å¶zs„ÅßÂá¶ÁêÜ
[[plugins]]
repo = 'emonkak/vim-operator-sort'
depends = ['vim-operator-user']
hook_add = '''
  map zs <Plug>(operator-sort)
'''

# viw„Å™„Å© ÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Å¶zu/zU„ÅßÂá¶ÁêÜ / ÂΩìÂ∫ß„ÅØciw„Åß
[[plugins]]
repo = 'emonkak/vim-operator-comment'
depends = ['vim-operator-user']
hook_add = '''
  map zu <Plug>(operator-comment)
  map zU <Plug>(operator-uncomment)
'''

# viw„Å™„Å© ÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Å¶zc/zC„ÅßÂá¶ÁêÜ
[[plugins]]
repo = 'mopp/vim-operator-convert-case'
depends = ['vim-operator-user']
hook_add = '''
  map zc <Plug>(operator-convert-case-loop)
  map zC <Plug>(operator-convert-case-convert)
'''

# viw„Å™„Å© ÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Å¶zt/zl„ÅßÊ§úÁ¥¢
[[plugins]]
repo = 'tyru/operator-reverse.vim'
depends = ['vim-operator-user']
hook_add = '''
  map zt <Plug>(operator-reverse-text)
  map zl <Plug>(operator-reverse-lines)
'''

# Easy Operator(select,yank and other)

[[plugins]]
repo = 'haya14busa/vim-easyoperator-line'
depends = ['vim-easymotion']
hook_add = '''
  " let g:EasyOperator_line_do_mapping = 0
'''
hook_post_source = '''
  " default (prefix)l in omap/xmap
'''

[[plugins]]
repo = 'haya14busa/vim-easyoperator-phrase'
depends = ['vim-easymotion']
hook_add = '''
  " let g:EasyOperator_phrase_do_mapping = 0
'''
hook_post_source = '''
  " default (prefix)p in omap/xmap
'''

# Startup
# [[plugins]]
# repo = 'thinca/vim-splash'
# hook_add = '''
#   " let g:splash#path = ''
# '''

[[plugins]]
repo = 'mhinz/vim-startify'
depends = ['vital.vim']
hook_post_source = '''
  let s:Filepath = g:V.import('System.Filepath')
  let s:List     = g:V.import('Data.List')
  let s:String   = g:V.import('Data.String')

  let g:startify_padding_left=3
  let s:padding = repeat(" ", g:startify_padding_left)

  " filter func
  function! s:file_contains_list(base, list) abort
    let Filepath = g:V.import('System.Filepath')

    let root = expand(a:base, ":p")
    let filelist = copy(a:list)

    call filter(filelist, 'Filepath.contains(v:val, root)')
    return filelist[ : g:startify_files_number ]
  endfunction

  if exists('*mr#mru#list')
    function! s:mru_list() abort
      return mr#mru#list()
    endfunction
  else
    let g:startify_update_oldfiles = 1
    function! s:mru_list() abort
      let Filepath = g:V.import('System.Filepath')
      " oldfile refine unix/win path style
      let oldfiles = copy(v:oldfiles)
      call map(oldfiles, 'Filepath.realpath(v:val)')
      call map(oldfiles, 'fnamemodify(v:val, ":p:~")')
      return oldfiles
    endfunction
  endif

  function! s:skip_filter(path) abort
    if exists('g:startify_skiplist')
      for regexp in g:startify_skiplist
        try
          if a:path =~# regexp
            return 0
          endif
        catch
          call s:warn('Pattern '. string(regexp) .' threw an exception. Read :help g:startify_skiplist')
        endtry
      endfor
    endif
    return 1
  endfunction

  function! s:totallist() abort
    let Filepath = g:V.import('System.Filepath')

    let mru_total_list = s:mru_list()

    call filter(mru_total_list, '!Filepath.contains(v:val, expand(g:user.dir.cache_home))')
    call filter(mru_total_list, { _,v -> s:skip_filter(v) })

    let mru_total_list = mru_total_list[ : g:startify_files_number ]

    call map(mru_total_list, { k, v -> { 'line': fnamemodify(v, ":p:~") , 'path': v } })
    return mru_total_list
  endfunction

  function! s:currentlist() abort
    let Filepath = g:V.import('System.Filepath')

    let mru_current_list = s:file_contains_list(getcwd(), s:mru_list())

    call filter(mru_current_list, '!Filepath.contains(v:val, g:user.dir.cache_home)')
    if exists('g:memolist_path')
      call filter(mru_current_list, '!Filepath.contains(v:val, g:memolist_path)')
    endif
    if exists('g:junkfile#directory')
      call filter(mru_current_list, '!Filepath.contains(v:val, g:junkfile#directory)')
    endif
    call filter(mru_current_list, { _,v -> s:skip_filter(v) })

    call map(mru_current_list, { k, v -> { 'line': fnamemodify(v, ":p:.") , 'path': v } })
    return mru_current_list
  endfunction

  function! s:memolist() abort
    let mru_memo_list = []
    if exists('g:memolist_path')
      let mru_memo_list = s:file_contains_list(g:memolist_path, s:mru_list())

      call map(mru_memo_list, { k, v -> { 'line': fnamemodify(v, ":p:t") , 'path': v } })
    endif
    return mru_memo_list
  endfunction

  function! s:junklist() abort
    let mru_junk_list = []
    if exists('g:junkfile#directory')
      let mru_junk_list = s:file_contains_list(g:junkfile#directory, s:mru_list())

      call map(mru_junk_list, { k, v -> { 'line': fnamemodify(v, ":p:t") , 'path': v } })
    endif

    return mru_junk_list
  endfunction

  let g:startify_lists = [
    \ { 'header': [s:padding . 'MRU']            , 'type': { -> s:totallist() }   },
    \ { 'header': [s:padding . 'MRU pwd']        , 'type': { -> s:currentlist() } },
    \ { 'header': [s:padding . 'memos']          , 'type': { -> s:memolist() }    },
    \ { 'header': [s:padding . 'junkfiles']      , 'type': { -> s:junklist() }    },
    \ { 'header': [s:padding . 'Sessions']       , 'type': 'sessions'             },
    \ { 'header': [s:padding . 'Bookmarks']      , 'type': 'bookmarks'            },
    \ { 'header': [s:padding . 'Commands']       , 'type': 'commands'             },
    \]

  let g:startify_files_number = 8

  let g:startify_bookmarks = [
    \ {'g': '~/.gvimrc'},
    \ {'x': '~/.vimrc'},
    \ {'c': '~/.vim/rc/colorscheme.toml'},
    \ {'d': '~/.vim/rc/dein.toml'},
    \ {'z': '~/.vim/rc/dein_lazy.toml'},
    \ {'w': '~/.bashrc'},
    \]

  " no need depend : write as text (if no-exist , no work)
  let g:startify_commands = [
    \ {'h': ':help help'},
    \ {'r': ['Restart', 'Restart']},
    \ {'u': ['Plugin update', 'DeinUpdateStart']},
    \ {'l': ['CtrlP Launcher', 'CtrlPLauncher']},
    \ {'f': ['LeaderF file search', 'Leaderf file']},
    \ {'m': ['Mastodon', 'Mastodon timeline']},
    \ {'o': ['Qiita', 'Qiita -l']},
    \ {'p': ['Calendar', 'Calendar -split=vertical -s:position=right']},
    \]

  " let g:startify_disable_at_vimenter=0
  " This value as default
  if has('win32unix')
    " MSYS vim (git for windows) very slowly : reason startify syntax too long
    let g:startify_disable_at_vimenter=1
  endif

  " ignore server name
  " let g:startify_skiplist_server = [ 'GVIM' ]

  " ignore MRU file
  " Git and other special files
  let s:special_skip_list = [
        \  s:Filepath.separator() . '.git' . s:Filepath.separator(),
        \ 'fugitiveblame$',
        \]

  " Vim help files
  " s:position
  let s:dein_path = fnamemodify(s:Filepath.realpath(
        \    g:dein.dir.plugins . s:Filepath.separator() .
        \    '.cache' . s:Filepath.separator() .
        \    '.vimrc' . s:Filepath.separator() .
        \    '.dein'
        \  ), ":p:~")
  let s:dein_relpath = s:String.replace_first(s:dein_path, '~' . s:Filepath.separator(), '')

  let s:position = [
        \  s:Filepath.abspath(resolve($VIMRUNTIME)) . s:Filepath.separator(),
        \ 'runtime'                               . s:Filepath.separator(),
        \ 'bundle'  . s:Filepath.separator() . '.*' . s:Filepath.separator(),
        \ 'plugged' . s:Filepath.separator() . '.*' . s:Filepath.separator(),
        \ s:dein_relpath,
        \]
  let s:helpfiles = ['.*\.txt', '.*\.jax']

  let s:help_skip_list = []
  for s:helpfile in s:helpfiles
    let s:help_skip_list = s:List.concat([s:help_skip_list, s:List.map(s:position,
          \ { v ->  escape(v . 'doc' . s:Filepath.separator(), '\') . s:helpfile })])
  endfor

  let g:startify_skiplist = s:List.concat([get(g:, 'startify_skiplist',[]), s:special_skip_list, s:help_skip_list])

  " let g:startify_fortune_use_unicode=1
  " autocmd MyAutoGroup User Startified nested setlocal ambiwidth=single
  " oops: open mru and other keep ambiwidth...

  let s:logo = [
        \ '___    ______________  ___',
        \ '__ |  / /___  _/__   |/  /',
        \ '__ | / / __  / __  /|_/ /',
        \ '__ |/ / __/ /  _  /  / /',
        \ '_____/  /___/  /_/  /_/',
        \]

  let s:datetime = ['*** '.strftime("%Y/%m/%d(%a)", localtime()).' ***']
  let g:startify_custom_header =
        \ map(s:logo + startify#fortune#boxed() + s:datetime, 's:padding . v:val')
  " space same as padding_left

  let s:vimver = ['vim version:', ' ' . 'short:' . string(v:version)]
  if exists('v:versionlong')
    call add(s:vimver, ' ' . 'long :' . string(v:versionlong))
  endif
  let g:startify_custom_footer =
        \ map(s:vimver, 's:padding . v:val')

  unlet s:Filepath s:List s:String
'''

[[plugins]]
repo = 'simeji/winresizer'
hook_add = '''
  let g:winresizer_vert_resize = 1
  let g:winresizer_horiz_resize = 1
'''

[[plugins]]
repo = 't9md/vim-choosewin'
hook_add = '''
  " use overlay feature
  let g:choosewin_overlay_enable = 1

  " workaround for the overlay font being broken on mutibyte buffer.
  " let g:choosewin_overlay_clear_multibyte = 1
'''
hook_post_source = '''
  " invoke with '-' : original
  " key bind to ',-'
  nmap  <Leader>-  <Plug>(choosewin)
'''

# [[plugins]]
# repo = 'justincampbell/vim-eighties'
# hook_add = '''
#   let g:eighties_enabled = 1
#   autocmd MyAutoGroup VimEnter,VimResized * let g:eighties_minimum_width = min([(&columns * 2 / 3), 60])
#   let g:eighties_extra_width = 10 " Increase this if you want some extra room
#   let g:eighties_compute = 1 " Disable this if you just want the minimum + extra
#   let g:eighties_bufname_additional_patterns = [] " Defaults to [], 'fugitiveblame' is only an example. Takes a comma delimited list of bufnames as strings.
# '''

[[plugins]]
repo = 'tyru/open-browser.vim'
hook_add = '''
  let g:netrw_nogx = 1 " disable netrw's gx mapping.
  nmap gx <Plug>(openbrowser-smart-search)
  vmap gx <Plug>(openbrowser-smart-search)
'''

[[plugins]]
repo = 'tyru/open-browser-unicode.vim'
depends = ['open-browser.vim']

[[plugins]]
repo = 'itchyny/calendar.vim'
hook_add = '''
  " let g:calendar_frame = 'default'

  let g:calendar_first_day = "sunday"
  let g:calendar_view = "days"

  let g:calendar_google_calendar = 1
  let g:calendar_google_task = 1

  let g:calendar_updatetime = &updatetime
'''

[[plugins]]
repo = 'thinca/vim-themis'

# based on https://qiita.com/lighttiger2505/items/96d4cda9074f9719bc82
[[plugins]]
repo = 'tpope/vim-dispatch'
hook_add = '''
  let g:dispatch_no_maps = 1
  " need mapping if required
'''

[[plugins]]
repo = 'janko-m/vim-test'
depends = ['vim-dispatch']
hook_add = '''
  let g:test#strategy = 'dispatch'
'''

# Doc & File & Web
[[plugins]]
repo = 'vim-jp/vimdoc-ja'
hook_add = '''
  " based on http://haya14busa.com/reading-vim-help/
  set helplang& helplang=ja,en
'''

[[plugins]]
repo = 'mattn/learn-vimscript'

# plugin support
[[plugins]]
repo = 'mopp/layoutplugin.vim'
hook_add = '''
  let g:layoutplugin#user_name = g:user.name " always my name
  " let g:layoutplugin#is_append_vimrc
  " let g:layoutplugin#is_suffix_readme_md
  let g:layoutplugin#is_suffix_plugin_name = 0
  " When set .vim; manually
'''

[[plugins]]
repo = 'LeafCage/vimhelpgenerator'
hook_add = '''
  let g:vimhelpgenerator_author = 'Author  : ' . g:user.name . ' <' . g:user.devemail . '>' " always my name
  let g:vimhelpgenerator_uri = 'https://github.com/tsuyoshicho/'
  let g:vimhelpgenerator_defaultlanguage = 'en'
  let g:vimhelpgenerator_contents =  {
  \ 'contents'     : 1,
  \ 'introduction' : 1,
  \ 'usage'        : 1,
  \ 'interface'    : 1,
  \ 'variables'    : 1,
  \ 'commands'     : 1,
  \ 'key-mappings' : 1,
  \ 'functions'    : 1,
  \ 'setting'      : 1,
  \ 'todo'         : 0,
  \ 'changelog'    : 0,
  \}

  let g:vimhelpgenerator_virtualhelpopencmd ='tabnew'

  function! s:vimhelpgen(lang,...) abort
    let backup = get(g:, 'vimhelpgenerator_defaultlanguage', 'en')
    let g:vimhelpgenerator_defaultlanguage = a:lang
    let arglist = extend([0],a:000)
    call call('vimhelpgenerator#generate', arglist)
    let g:vimhelpgenerator_defaultlanguage = backup
  endfunction

  command! -nargs=* VimHelpGeneratorEn call s:vimhelpgen('en', <f-args>)
  command! -nargs=* VimHelpGeneratorJa call s:vimhelpgen('ja', <f-args>)
'''

[[plugins]]
repo = 'rhysd/devdocs.vim'
depends = ['open-browser.vim']

# contents
[[plugins]]
repo = 'chrisbra/unicode.vim'

[[plugins]] # „Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆft„ÇíÂà§ÂÆö„Åô„Çã„É©„Ç§„Éñ„É©„É™
repo = 'Shougo/context_filetype.vim'
# repo = 'tsuyoshicho/context_filetype.vim'
# rev = 'develop'
hook_post_source = '''
  let s:default_filetypes = g:context_filetype#default_filetypes()

  let s:plantuml_context = [
        \  {
        \   'start' : '\_.\%(@start\(uml\|gantt\|ditaa\|salt\|wbs\|mindmap\|math\|latex\)\)\@=',
        \   'end' : '\%(@end\1\)\@<=\_.', 'filetype' : 'plantuml'
        \  },
        \ ]

      " currently broken
  let s:yaml_context = [
        \  {
        \   'start' : '\%^-\{3,}.*$',
        \   'end' : '\_^-\{3,}.*$',
        \   'filetype' : 'yaml'
        \  },
        \ ]

  for s:key in ['markdown','text']
    let g:context_filetype#filetypes[s:key] = extend(
      \ s:plantuml_context,
      \ get(s:default_filetypes, s:key, [])
      \)
  endfor

  " same as typename
  let g:context_filetype#same_filetypes =
        \extend(get(g:, 'context_filetype#same_filetypes', {}),
        \ {
        \  'yml' : 'yaml',
        \ }
        \)
'''

[[plugins]] # „Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Å´Âêà„Çè„Åõ„Å¶ft„ÇíÂàá„ÇäÊõø„Åà„Çã
repo = 'osyo-manga/vim-precious'
depends = ['context_filetype.vim', 'vim-textobj-user']
# and support context textobj
hook_add = '''
  " move to change disable
  let g:precious_enable_switch_CursorMoved = {
  \  "*"    : 0,
  \  "help" : 1,
  \}
  let g:precious_enable_switch_CursorMoved_i = {
  \  "*" : 0,
  \}
'''

[[plugins]]
repo = 'wellle/context.vim'
hook_add = '''
  " default disable
  let g:context_enabled = 0
  let g:context_add_mappings = 0
  let g:context_filetype_blacklist = []
'''

[[plugins]]
repo = 'LeafCage/taillight.vim'
hook_add = '''
  " „Çª„Éü„Ç≥„É≠„É≥Êú´Â∞æ„ÅÆË®ÄË™û„ÇíËøΩÂä†
  " JavaScript„ÅØÈô§Â§ñ(ÊâãÂãï„Åß)
  " autocmd MyAutoGroup FileType c,cpp,java nested TailLight ; /\* \*/
'''

[[plugins]]
repo = 'tsuyoshicho/vim-fg'
hook_post_source = '''
  nnoremap <silent> <Leader>mg :<C-u>Fg<CR>

  " usable define
  nnoremap <silent> <Leader>mp :<C-u>FgPt<CR>
  " vnoremap <silent> <Leader>mp :<C-u>FgPt <need visual-select item><CR>
  nnoremap <silent> <Leader>ma :<C-u>FgAg<CR>
'''

# autocomplete
[[plugins]]
repo = 'prabirshrestha/vim-lsp'
hook_add = '''
  let g:lsp_async_completion = 1

  let g:lsp_auto_enable = 1          " default 1
  let g:lsp_diagnostics_enabled = 1  " default 1

  let s:float_ok = 0
  if has('nvim')
    let s:float_ok = 1
  elseif has('popupwin') || exists('*popup_create')
    let s:float_ok = 1
  endif

  if s:float_ok
    let g:lsp_preview_float = 1
    let g:lsp_diagnostics_float_cursor = 1
    let g:lsp_diagnostics_echo_cursor = 0 " default 0 enable echo under cursor when in normal mode
  else
    let g:lsp_preview_float = 0
    let g:lsp_diagnostics_float_cursor = 0
    let g:lsp_diagnostics_echo_cursor = 1 " default 0 enable echo under cursor when in normal mode
  endif

  " folding
  " let g:lsp_fold_enabled = 0 " default 1 enable

  " icon setting
  " use vim-lsp-icons plugin
  " let g:lsp_signs_error       = {'text': 'üî•'}
  " let g:lsp_signs_warning     = {'text': '‚ùó'}
  " let g:lsp_signs_information = {'text': 'üëÅÔ∏è'}

  " server setup
  " mainly setting use vim-lsp-settings plugin

  " optional
  let g:lsp_item = []

  " efm server
  " use vim-efm-langserver-settings

  " c/c++ cquery
  " if executable('cquery')
  "   call add(g:lsp_item, {
  "        \ 'name': 'cquery',
  "        \ 'cmd': {server_info->['cquery']},
  "        \ 'root_uri': {
  "        \   server_info->lsp#utils#path_to_uri(
  "        \     lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), 'compile_commands.json')
  "        \   )
  "        \ },
  "        \ 'initialization_options': { 'cacheDirectory': '~/tmp/cquery/cache' },
  "        \ 'whitelist': ['c', 'cpp', 'objc', 'objcpp', 'cc'],
  "        \ })
  " endif

  function! s:lsp_user_setup() abort
    for item in g:lsp_item
      call lsp#register_server(item)
    endfor
  endfunction

  function! s:lsp_user_buffer_enabled() abort
    " option setup
    if dein#tap('asyncomplete-lsp.vim') && !dein#tap('asyncomplete-omni.vim')
      " use vim-lsp in complete engine asyncomplete and source omni do not
      " load , set omni vim-lsp function.
      setlocal omnifunc=lsp#complete
    endif

    " use vim built-in/plugin folding
    let exclude_types = ['markdown','help']
    if get(g:, 'lsp_fold_enabled', 0)
      let skip = 0
      for filetype_name in split(&filetype, '\.')
        if index(exclude_types, filetype_name) > -1
          let skip = 1
        end
      endfor
      if !skip
        setlocal foldmethod=expr
        setlocal foldexpr=lsp#ui#vim#folding#foldexpr()
      endif
    endif

    " keymap
    nmap <silent><buffer> <f1>       <plug>(lsp-hover)
    nmap <silent><buffer> <f2>       <plug>(lsp-rename)

    nmap <silent><buffer> gd         <plug>(lsp-definition)
    nmap <silent><buffer> <Leader>K  <plug>(lsp-hover)
    nmap <silent><buffer> <Leader>md <plug>(lsp-document-diagnostics)
    nmap <silent><buffer> <Leader>mr <plug>(lsp-references)

    nmap <silent><buffer> ]e         <plug>(lsp-next-diagnostic)
    nmap <silent><buffer> [e         <plug>(lsp-previous-diagnostic)
    nmap <silent><buffer> ]r         <plug>(lsp-next-reference)
    nmap <silent><buffer> [r         <plug>(lsp-previous-reference)
  endfunction

  augroup vimrc_init-vim-lsp
    autocmd!
    autocmd User lsp_setup          nested call s:lsp_user_setup()
    autocmd User lsp_buffer_enabled nested call s:lsp_user_buffer_enabled()
  augroup END

'''
hook_post_source = '''
  " from https://mattn.kaoriya.net/software/vim/20191231213507.htm
  command! LspDebugEnable  let lsp_log_verbose=1 | let lsp_log_file=expand($HOME . '/lsp.log')
  command! LspDebugDisable let lsp_log_verbose=0 | unlet lsp_log_file
'''

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
hook_add = '''
  let g:vsnip_snippet_dir = expand(g:user.dir.config_home . '/snippet')
  call g:user.function.mkdir(g:vsnip_snippet_dir)
'''
hook_post_source = '''
  " Expand
  imap <expr> <C-b>  vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-b>'
  smap <expr> <C-b>  vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-b>'

 " Expand or jump
  imap <expr> <C-CR> vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-CR>'
  smap <expr> <C-CR> vsnip#available(1)  ? '<Plug>(vsnip-expand-or-jump)' : '<C-CR>'

  " Jump forward or backward
  imap <expr> <C-n>  vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<C-n>'
  smap <expr> <C-n>  vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<C-n>'
  imap <expr> <C-p>  vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<C-p>'
  smap <expr> <C-p>  vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<C-p>'
'''

[[plugins]]
repo = 'hrsh7th/vim-vsnip-integ'
depends = ['vim-lsp', 'asyncomplete.vim', 'vim-vsnip']

[[plugins]]
repo = 'mattn/vim-lsp-settings'
merged = 0
depends = ['vim-lsp', 'vital.vim']
hook_add = '''
  " install path
  " ~/.local/share/vim-lsp-settings/
  let g:lsp_settings_servers_dir = expand(g:user.dir.data_home . '/vim-lsp-settings')
  call g:user.function.mkdir(g:lsp_settings_servers_dir)

  " config
  " system-wide / per lsp server

  " global / per lsp server
  let g:lsp_settings = {}

  " affect high-priority vim-lsp-settings installed clangd
  " detect clangd path
  " 1. vim-lsp-installed clangd
  " 2. system installed clangd
  let s:clangd_path = g:lsp_settings_servers_dir . '/clangd/clangd'
  if !executable(s:clangd_path)
    " „Ç∑„Çπ„ÉÜ„É†„Å´„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Åü„Éê„Éº„Ç∏„Éß„É≥„ÇíÂà©Áî®„Åó„Åæ„Åô„Åå„ÄÅ
    " „Åì„Çå„Åå'-j'„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„Å™„ÅÑÂ†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ
    " Use the version installed on your system, which may not support'-j '.
    let s:clangd_path = exepath('clangd')
  endif

  " prefer python 3, detect python 3 version
  " 1. use if python is pytnon3
  " 2. use if python3 avaliable
  if executable('python')
    " check 'python'
    let s:py_path    = exepath('python')
    let s:py_version = system(shellescape(s:py_path) . ' -V')
    let s:py_ver     = trim(matchstr(s:py_version, '\s\zs\S\+'))
    if (empty(s:py_ver) || ('2' ==? strpart(s:py_ver, 0, 1)))
        \ && executable('python3')
      " 'python' is version2 and exists 'python3'
      let s:py_path    = exepath('python3')
      let s:py_version = system(shellescape(s:py_path) . ' -V')
      let s:py_ver     = trim(matchstr(s:py_version, '\s\zs\S\+'))
    endif
  endif

  " clangd installed?
  " set at cpunum
  if executable(s:clangd_path)
    let g:lsp_settings['clangd'] = {
      \  'cmd': [ s:clangd_path, '--background-index', '-j=' . g:user.system.cpunum ],
      \}
  endif

  " python3 available?
  " prefer python 3 than 2(at python command in vim-lsp-setting)
  if !empty(s:py_ver)
    let g:lsp_settings['pyls-ms'] = {
      \  'python-path' : s:py_path,
      \  'python-ver'  : s:py_ver,
      \}
  endif

  let g:lsp_settings['gopls'] = {
    \  'workspace_config': {
    \    'usePlaceholders': v:true,
    \    'analyses': {
    \      'fillstruct': v:true,
    \    },
    \  },
    \  'initialization_options': {
    \    'usePlaceholders': v:true,
    \    'analyses': {
    \      'fillstruct': v:true,
    \    },
    \  },
    \}

  let g:lsp_settings['yaml-language-server'] = {
    \  'workspace_config': {
    \    'yaml': {
    \       'schemas': {
    \       },
    \       'completion': v:true,
    \       'hover': v:true,
    \       'validate': v:true,
    \     }
    \   }
    \ }
  " scheme example  'https://mattn.github.io/efm-langserver/schema.json': '/efm-langserver/config.yaml'

  " per filetype
  " let g:lsp_settings_filetype_vim    = ['vimscript-language-server']
  let g:lsp_settings_filetype_python = ['pyls-ms']
'''
hook_post_source = '''
  let s:List     = g:V.import('Data.List')

  let g:lsp_settings_root_markers = s:List.concat([
    \ s:List.map(g:user.rootmarker.dirs, { v ->  v . '/' }),
    \ g:user.rootmarker.files])
  unlet s:List
'''

[[plugins]]
repo = 'tsuyoshicho/vim-efm-langserver-settings'
# rev  = 'develop'
depends = ['vim-lsp']
hook_add = '''
  " debug
  " let g:efm_langserver_settings#debug = 1

  " let g:efm_langserver_settings#config_file = '<custom file>'
  " let g:efm_langserver_settings#debug_file  = '<custom file>'
  " let g:efm_langserver_settings#customlist = 0
  " let g:efm_langserver_settings#config     = 1
  " let g:efm_langserver_settings#debug      = 0
  " let g:efm_langserver_settings#filetype_whitelist = []
  " let g:efm_langserver_settings#filetype_blacklist = []
'''

[[plugins]]
repo = 'mattn/vim-lsp-icons'
merged = 0
depends = ['vim-lsp']

# autocomplete
[[plugins]]
repo = 'prabirshrestha/asyncomplete.vim'
hook_add = '''
  " let g:asyncomplete_auto_popup = 0

  let g:asyncomplete_popup_delay = 200

  " default
  let g:asyncomplete_triggers = extend(get(g:,'asyncomplete_triggers',{}),
        \ {
        \   '*'  : ['.', '>', ':'],
        \ })

  " completeopt manual set
  let g:asyncomplete_auto_completeopt = 0

  " debug
  command! AsyncompleteDebugEnable  let g:asyncomplete_log_file = expand($HOME . '/asyncomplete.log')
  command! AsyncompleteDebugDisable unlet g:asyncomplete_log_file
'''
hook_post_source = '''
  imap     <c-space>      <Plug>(asyncomplete_force_refresh)

  " augroup vimrc_init-asyncomplete
  "   autocmd!
  "   " asyncomplete original
  "   " autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif
  "   " my refine
  "   autocmd CompleteDone * if pumvisible() | pclose | endif
  " augroup END
'''

[[plugins]]
repo = 'machakann/asyncomplete-ezfilter.vim'
depends = ['asyncomplete.vim']
hook_source = '''
  let g:asyncomplete_preprocessor =
  \ [function('asyncomplete#preprocessor#ezfilter#filter')]

  let g:asyncomplete#preprocessor#ezfilter#config = {}

  " https://gist.github.com/mattn/d909c93784aa81d97b82c0896ef38ca8
  " basic fuzzy match
  function! s:fuzzy(lhs, rhs) abort
    return a:lhs =~ join(map(split(a:rhs, '\zs'), "printf('[\\x%02x].*', char2nr(v:val))"), '')
  endfunction

  let g:asyncomplete#preprocessor#ezfilter#config['*'] =
  \ {ctx, items -> filter(items, 's:fuzzy(v:val.word, ctx.base) != 0')}

  " if has python3 advanced match
  if has('python3')
    " osa_filter is slow when running in vim script so only set if python3 is enabled
    let g:asyncomplete#preprocessor#ezfilter#config['*'] =
    \ {ctx, items -> ctx.osa_filter(items, 1)}
  endif
'''

[[plugins]]
repo = 'machakann/asyncomplete-unicodesymbol.vim'
depends = ['asyncomplete.vim', 'asyncomplete-ezfilter.vim']
hook_source = '''
  if v:false
    autocmd User asyncomplete_setup call
      \ asyncomplete#register_source(
      \   asyncomplete#sources#unicodesymbol#get_source_options({
      \     'name': 'unicodesymbol',
      \     'whitelist': ['julia'],
      \     'completor': function('asyncomplete#sources#unicodesymbol#completor'),
      \   }))

    let g:asyncomplete#preprocessor#ezfilter#config.unicodesymbol =
      \ {ctx, items -> filter(items, 'ctx.match(v:val.menu)')}
  endif
'''

[[plugins]]
# repo = 'yuki-ycino/asyncomplete-dictionary'
repo = 'tsuyoshicho/asyncomplete-dictionary'
rev  = 'develop'
depends = ['asyncomplete.vim']
hook_source = '''
  if v:false
    autocmd User asyncomplete_setup call
      \ asyncomplete#register_source(
      \   asyncomplete#sources#dictionary#get_source_options({
      \     'name': 'dictionary',
      \     'whitelist': ['*'],
      \     'completor': function('asyncomplete#sources#dictionary#completor')
      \   }))
  endif
'''

[[plugins]]
repo = 'prabirshrestha/asyncomplete-lsp.vim'
depends = ['vim-lsp', 'asyncomplete.vim']
hook_source = '''
  " debug
  if v:false
    autocmd User lsp_setup             echomsg "lsp_setup             execute"
    autocmd User lsp_register_server   echomsg "lsp_register_server   execute"
    autocmd User lsp_unregister_server echomsg "lsp_unregister_server execute"
    autocmd User lsp_server_init       echomsg "lsp_server_init       execute"
    autocmd User lsp_server_exit       echomsg "lsp_server_exit       execute"
    autocmd User lsp_complete_done     echomsg "lsp_complete_done     execute"
    autocmd User lsp_float_opened      echomsg "lsp_float_opened      execute"
    autocmd User lsp_float_closed      echomsg "lsp_float_closed      execute"
    autocmd User lsp_buffer_enabled    echomsg "lsp_buffer_enabled    execute"
  endif
'''

[[plugins]]
repo = 'high-moctane/asyncomplete-nextword.vim'
depends = ['asyncomplete.vim']
hook_source = '''
  if v:false
    let $NEXTWORD_DATA_PATH = expand(g:user.dir.dictionary . '/nextword')
    if executable('nextword')
      autocmd User asyncomplete_setup call
        \ asyncomplete#register_source(
        \   asyncomplete#sources#nextword#get_source_options({
        \     'name': 'nextword',
        \     'whitelist': ['*'],
        \     'args': ['-n', '300', '-g'],
        \     'completor': function('asyncomplete#sources#nextword#completor')
        \   }))
    endif
  endif
'''

[[plugins]]
repo = 'gonzoooooo/asyncomplete-look.vim'
depends = ['asyncomplete.vim']
hook_source = '''
  if v:false
    if executable('look')
      autocmd User asyncomplete_setup call
        \ asyncomplete#register_source(
        \   asyncomplete#sources#look#get_source_options({
        \     'name': 'look',
        \     'whitelist': ['*'],
        \     'completor': function('asyncomplete#sources#look#completor'),
        \   }))
    endif
  endif
'''

[[plugins]]
repo = 'prabirshrestha/asyncomplete-file.vim'
depends = ['asyncomplete.vim']
hook_source = '''
  if v:true
    autocmd User asyncomplete_setup call
      \ asyncomplete#register_source(
      \   asyncomplete#sources#file#get_source_options({
      \     'name': 'file',
      \     'whitelist': ['*'],
      \     'priority': 10,
      \     'completor': function('asyncomplete#sources#file#completor')
      \   }))
  endif
'''

[[plugins]]
repo = 'prabirshrestha/asyncomplete-buffer.vim'
depends = ['asyncomplete.vim']
hook_source = '''
  if v:true
    autocmd User asyncomplete_setup call
      \ asyncomplete#register_source(
      \   asyncomplete#sources#buffer#get_source_options({
      \     'name': 'buffer',
      \     'whitelist': ['*'],
      \     'blacklist': ['go','python'],
      \     'completor': function('asyncomplete#sources#buffer#completor'),
      \     'config': {
      \        'max_buffer_size': 700000,
      \      },
      \ }))
  endif
'''

[[plugins]]
repo = 'prabirshrestha/asyncomplete-emmet.vim'
depends = ['asyncomplete.vim', 'emmet-vim']
hook_source = '''
  if v:true
    autocmd User asyncomplete_setup call
      \ asyncomplete#register_source(
      \   asyncomplete#sources#emmet#get_source_options({
      \     'name': 'emmet',
      \     'whitelist': ['html'],
      \     'completor': function('asyncomplete#sources#emmet#completor'),
      \ }))
  endif
'''

[[plugins]]
repo = 'prabirshrestha/asyncomplete-tags.vim'
depends = ['asyncomplete.vim']
hook_source = '''
  if v:false
    autocmd User asyncomplete_setup call
      \ asyncomplete#register_source(
      \   asyncomplete#sources#tags#get_source_options({
      \     'name': 'tags',
      \     'whitelist': ['c','cpp','objc','objcpp','vim','javascript','typescript'],
      \     'completor': function('asyncomplete#sources#tags#completor'),
      \     'config': {
      \       'max_file_size': 350000000,
      \     },
      \   }))
  endif
'''

[[plugins]]
repo = 'prabirshrestha/asyncomplete-emoji.vim'
depends = ['asyncomplete.vim']
hook_source = '''
  if v:true
    autocmd User asyncomplete_setup call
      \ asyncomplete#register_source(
      \   asyncomplete#sources#emoji#get_source_options({
      \     'name': 'emoji',
      \     'whitelist': ['markdown', 'text'],
      \     'completor': function('asyncomplete#sources#emoji#completor'),
      \   }))
  endif
'''

# [[plugins]] # completion <C-X><C-U> (user completion)
# repo = 'junegunn/vim-emoji'
# hook_post_source = '''
#   " set default user completion function
#   set completefunc=emoji#complete
#
#   " replace :emoji: to <unicode-emoji>
#   " try echo unicode
#   function! s:emoji_unicode_echo ()
#     let l:keywords=&iskeyword
#     setlocal iskeyword-=:
#     let l:word = expand('<cword>')
#     let l:gh_word = ':'.l:word.':'
#     if '' !=? emoji#for(l:word)
#       echo 'emoji :'.expand('<cword>').'-'.emoji#for(l:word)
#     else
#       echo 'emoji :'.expand('<cword>').'-'.'(no match)'
#     endif
#     let &iskeyword=l:keywords
#   endfunction
#
#   nnoremap <silent> <Leader>e :call <SID>emoji_unicode_echo()<CR>
#
#   function! s:emoji_unicode_replace ()
#     let l:keywords=&iskeyword
#     setlocal iskeyword-=:
#     let l:word = expand('<cword>')
#     if word == ''
#       let &iskeyword=l:keywords
#       return
#     endif
#
#     let l:gh_word = ':'.l:word.':'
#     if '' !=? emoji#for(l:word)
#       " „Ç´„Éº„ÇΩ„É´‰ΩçÁΩÆ„ÇíwordÂàÜÂâç„Å´Âãï„Åã„Åó„Å¶„Åã„Çâ„ÄÅ„Åù„ÅÆ‰ΩçÁΩÆ„Åã„ÇâÂæå„ÅÆÊúÄÂàù„ÅÆword„ÇíÁΩÆÊèõ„Åô„Çã
#       " ÂÆå‰∫ÜÂæå„ÄÅ‰ΩçÁΩÆ„ÇíÁßªÂãï
#       "   123456789ABCD
#       "   smile :smile:
#       "   ^____ origin cursor
#       "   ^____ replace match start (word match pos - colon_size (min:1))
#       "   ^____ if success; search emoji start (same replace match)
#
#       "   smile :smile:
#       "   __^__ origin cursor
#       "   ^____ replace match start (word match pos - colon_size (min:1))
#       "   ^____ if success; search emoji start (same replace match)
#
#       "   smile :smile:
#       "   ________^__ origin cursor
#       "   ___^_______ word matchs start (origin - word len(min:1))
#       "   ______^____ replace match start (word match pos - colon_size (min:1))
#       "   ______^____ if success; search emoji start (same replace match)
#
#       let pos = getcurpos()
#       let word_col = pos[2]
#       let target_col = pos[2]
#       if pos[2] != 1
#         " Ë°åÈ†≠‰ª•Â§ñ„ÅØ‰ΩçÁΩÆË£úÊ≠£„Åô„Çã
#         let word_col = pos[2] - strlen(l:word)
#         if word_col < 1 | let word_col = 1 | endif
#
#         let target_col = word_col
#         if word_col != 1
#           call cursor(pos[1], word_col)
#           call search(l:word)
#
#           let target_pos = getcurpos()
#           let target_col = target_pos[2] - 1 " : „ÅÆÂàÜ
#           if target_col < 1 | let target_col = 1 | endif
#         endif
#       endif
#
#       call cursor(pos[1], target_col)
#
#       let l:success = 0
#       try
#         call execute('substitute' . '/' . '\%#'.l:gh_word . '/' . '\=emoji#for(l:word)' . '/')
#         let l:success = 1
#       catch
#         " let l:success = 0
#       finally
#         call cursor(pos[1], pos[2])
#       endtry
#
#       if l:success
#         call cursor(pos[1], target_col)
#         call search(emoji#for(l:word), 'z')
#       endif
#
#     endif
#     let &iskeyword=l:keywords
#   endfunction
#
#   nnoremap <silent> <Leader>E :call <SID>emoji_unicode_replace()<CR>
# '''

# CtrlP
# other plugin within ctrlp extension
# - vim-pass
# - yankround.vim
# - spelunker.vim
# - (lazy plugins)
[[plugins]]
repo = 'ctrlpvim/ctrlp.vim'
# For collision avoidance, dependent setting : lightline
depends = ['vital.vim', 'lightline.vim']
hook_add = '''
  " based on http://leafcage.hateblo.jp/entry/2013/10/21/lightlinevim-customize
  function! CtrlPEnter()
    let w:lightline = 0
  endfunction

  function! CtrlPLeave()
    call g:lightline#update()
  endfunction

  let g:ctrlp_buffer_func = {
        \ 'enter': 'CtrlPEnter',
        \ 'exit' : 'CtrlPLeave'
        \}

  " based on https://kamiya555.github.io/2016/07/24/vim-ctrlp/
  " „Ç≠„É£„ÉÉ„Ç∑„É•„Éá„Ç£„É¨„ÇØ„Éà„É™
  let g:ctrlp_use_caching = 1
  let g:ctrlp_cache_dir = expand(g:user.dir.cache_home . '/ctrlp')
  call g:user.function.mkdir(g:ctrlp_cache_dir)

  " CtrlP„ÅÆ„Ç¶„Ç£„É≥„Éâ„Ç¶ÊúÄÂ§ßÈ´ò„Åï
  autocmd MyAutoGroup VimEnter,VimResized *
    \ let g:ctrlp_match_window = 'max:' . string(min([(&lines/3), 20]) - 1)

  " ÁÑ°Ë¶ñ„Åô„Çã„Éá„Ç£„É¨„ÇØ„Éà„É™
  " let g:ctrlp_custom_ignore = {
  "   \ 'dir':  '\v[\/]\.(svn|git|hg|bzr)$',
  "   \ 'file': '\v\.(exe|so|dll)$',
  "   \ 'link': 'some_bad_symbolic_links',
  "   \ }

  let g:ctrlp_brief_prompt = 1
  " let g:ctrlp_user_command_async = 1

  " input japanese
  let g:ctrlp_key_loop = 1

  " based on https://qiita.com/0829/items/7053b6e3371592e4fbe6
  " based on https://christina04.hatenablog.com/entry/2014/10/30/100612
  " based on https://postd.cc/how-to-boost-your-vim-productivity/
  if executable('files')
    let s:fallback_cmd = 'cd %s && files -m ""'
  " ripgrep only support glob -g / -l search and filename only
  " elseif executable('rg')
  "   let s:fallback_cmd = 'rg --color never -S -l "" %s'
  elseif executable('pt')
    let s:fallback_cmd = 'pt --nocolor --nogroup -S -g "" %s'
  elseif executable('ag')
    let s:fallback_cmd = 'ag -a --nocolor --nogroup -S -g "" %s'
  " jvgrep no support filename match
  " elseif executable('jvgrep')
  "   let s:fallback_cmd = 'jvgrep --no-color -Rril "" %s'
  endif
  if exists('s:fallback_cmd')
    if executable('nkf')
      let s:fallback_cmd =  s:fallback_cmd . ' | nkf -w'
    endif
  endif

  let g:ctrlp_user_command = {
        \   'types': {
        \     1: ['.git', 'git -C %s ls-files'     ],
        \     2: ['.hg',  'hg --cwd %s locate -I .'],
        \     3: ['.svn', 'cd %s && svn ls .'      ],
        \     4: ['.bzr', 'cd %s && bzr ls .'      ],
        \   },
        \ }
  if exists('s:fallback_cmd')
    let g:ctrlp_use_caching  = 0
    let g:ctrlp_user_command = extend(g:ctrlp_user_command,
          \ { 'fallback': s:fallback_cmd }, "keep")
  endif

  " let g:ctrlp_cmd = 'CtrlP' " default

  " ext
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + [ 'dir' ,'line' , 'undo', 'changes','mixed' ]
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['tag']
'''
hook_post_source = '''
  let s:List     = g:V.import('Data.List')

  " „É´„Éº„Éà„Éë„Çπ„Å®Ë™çË≠ò„Åï„Åõ„Çã„Åü„ÇÅ„ÅÆ„Éï„Ç°„Ç§„É´
  let g:ctrlp_root_markers = s:List.concat([
    \ g:user.rootmarker.dirs,
    \ g:user.rootmarker.files])
  unlet s:List

  " matcher
  if dein#is_sourced('ctrlp-matchfuzzy') && exists('*matchfuzzy')
    let g:ctrlp_match_func = {'match' : 'ctrlp_matchfuzzy#matcher'}
    " fastest for built-in function
    let g:ctrlp_lazy_update = 10
  elseif dein#is_sourced('ctrlp-py-matcher') && has('python3')
    " python2 deprecated
    let g:ctrlp_match_func = {'match' : 'pymatcher#PyMatch'}
    " fast but python call small heavy
    let g:ctrlp_lazy_update = 20
  else
    " normal search more heavy
    let g:ctrlp_lazy_update = 50
  endif
'''

[[plugins]]
repo = 'mattn/ctrlp-matchfuzzy'
depends = ['ctrlp.vim']
# config in ctrlp.vim

[[plugins]]
repo = 'FelikZ/ctrlp-py-matcher'
depends = ['ctrlp.vim']
# config in ctrlp.vim

[[plugins]] # based on https://blog.kaneshin.co/entry/vim-advent-calendar-2012
repo = 'kaneshin/ctrlp-git-log'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['git_log']
'''

[[plugins]] # based on https://mattn.kaoriya.net/software/vim/20120427205409.htm
repo = 'mattn/ctrlp-mark'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['mark']
'''

[[plugins]] # based on https://mattn.kaoriya.net/software/vim/20120427205409.htm
repo = 'mattn/ctrlp-register'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['register']
'''

[[plugins]] # based on https://mattn.kaoriya.net/software/vim/20120427205409.htm
repo = 'mattn/ctrlp-launcher'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['launcher']

  let g:ctrlp_launcher_file = expand(g:user.dir.vim . '/launcher')
  nmap <silent> <F9> :CtrlPLauncher<CR>
'''

[[plugins]]
repo = 'ompugao/ctrlp-history'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['history/search', 'history/cmd']
'''

[[plugins]]
repo = 'suy/vim-ctrlp-commandline'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['commandline']
'''

[[plugins]]
repo = 'prabirshrestha/ctrlp-env'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['env']
'''

[[plugins]]
repo = 'ompugao/ctrlp-locate'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['locate']
'''

[[plugins]]
repo = 'hara/ctrlp-colorscheme'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
       \ + ['colorscheme']
'''

[[plugins]]
repo = 'endel/ctrlp-filetype.vim'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
       \ + ['filetype']
'''

[[plugins]]
# repo = 'sgur/ctrlp-extensions.vim'
repo = 'tsuyoshicho/ctrlp-extensions.vim'
rev  = 'develop'
depends = ['ctrlp.vim']
hook_add = '''
  " ['yankring', 'menu', 'cmd']

  " yank use LeafCage/yankround.vim
  let g:ctrlp_yankring_disable = 1
  " let g:ctrlp_yankring_limit = 50 " default 100
  " let g:ctrlp_yankring_minimum_chars = 4 " default 2

  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['menu', 'cmd']

  let g:ctrlp_cmd = 'CtrlPMenu' " menu override
'''

[[plugins]]
repo = 'zeero/vim-ctrlp-help'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['help']
'''

[[plugins]]
repo = 'DavidEGx/ctrlp-smarttabs'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['smarttabs']

  " let g:ctrlp_smarttabs_modify_tabline = 1
  " If 1 will highlight the selected file in the tabline.
  " (Default: 1)

  " let g:ctrlp_smarttabs_reverse = 1
  " Reverse the order in which files are displayed.
  " (Default: 1)

  let g:ctrlp_smarttabs_exclude_quickfix = 1
  " Exclude quickfix buffers.
  " (Default: 0)
'''

[[plugins]]
repo = 'mattn/ctrlp-lsp'
depends = ['vim-lsp', 'ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['lsp_document_symbol', 'lsp_workspace_symbol']
'''

[[plugins]] # w3m,lynx,wwwrenderer-vim„ÅÆ„Å©„Çå„Åã„ÅåÂøÖË¶Å
repo = 'thinca/vim-ref'
depends = ['wwwrenderer-vim']
# on_if= 'executable("lynx")' ÁèæÂú®„ÅÆÁí∞Â¢ÉÊßãÁØâ„Åß„ÅØ„Éë„Çπ„ÇíÈÄö„Åó„Å¶„Å™„ÅÑ
hook_add = '''
  " " Ëá™ÂãïË®≠ÂÆö
  " let g:ref_source_webdict_cmd
  " " 'lynx -dump -nonumbers %s'
  " " '=wwwrenderer#render("%s")'
  "
  " " same as ref_source_webdict_cmd
  " let g:ref_rfc_cmd
'''

[[plugins]] # JavaDoc
repo = 'LeafCage/ref-javadoc'
depends = ['vim-ref']
hook_add = '''
  " " Ëá™ÂãïË®≠ÂÆö
  " " same as ref_source_webdict_cmd
  " let g:ref_javadoc_cmd
  " " localpath
  " let g:ref_javadoc_path
'''

[[plugins]] # info
repo = 'eiiches/vim-ref-info'
depends = ['vim-ref']

# QuickRun & AsyncRun
[[plugins]]
repo = 'osyo-manga/quickrun-hook-u-nya-'

[[plugins]]
repo = 'mattn/vim-quickrunex'

[[plugins]]
repo = 'lambdalisue/vim-quickrun-neovim-job'

[[plugins]]
repo = 'thinca/vim-quickrun'
depends = ['vim-altercmd', 'vimproc.vim', 'quickrun-hook-u-nya-',  'open-browser.vim', 'vim-quickrunex']
hook_add = '''
  " <Plug>(precious-quickrun-op) in osyo-manga/vim-precious
  if dein#tap('vim-precious') " after load support : not dein#is_sourced
    nmap <Leader>o <Plug>(precious-quickrun-op)
  endif

  " if untype buffer, prev run timing type detect work hook
  "
  " config
  let g:quickrun_config = get(g:, 'quickrun_config', {})

  " global
  let g:quickrun_config['_'] = extend({
        \  'outputter'                       : 'error',
        \  'outputter/error/success'         : 'buffer',
        \  'outputter/error/error'           : 'multi',
        \  'outputter/multi/targets'         : ['loclist', 'popup'],
        \  'outputter/loclist/open_cmd'      : '',
        \  'outputter/buffer/split'          : ':rightbelow 8sp',
        \  'outputter/buffer/close_on_empty' : 1,
        \  'outputter/buffer/running_mark'   : '[running...]',
        \  "hook/slash/enable"               : 1,
        \  'hook/u_nya_/enable'              : 1,
        \}, get(g:quickrun_config, '_', {}), "keep")

  " per filetype
  let s:quickrun_filetype_encode_fixlist = ['python', 'ruby', 'markdown']

  " vim
  let g:quickrun_config['vim'] = extend({
        \  'hook/slash/enable' : 0,
        \}, get(g:quickrun_config, 'vim', {}), "keep")

  " markdown
  let g:quickrun_config['markdown'] = extend({
        \  'type' : 'markdown/pandoc',
        \  'outputter' : 'browser',
        \}, get(g:quickrun_config, 'markdown', {}), "keep")

  " python
  let g:quickrun_config['python'] = extend({
        \  'hook/time/enable' : 1,
        \}, get(g:quickrun_config, 'python', {}), "keep")

  " ruby
  let g:quickrun_config['ruby'] = extend({
        \  'hook/time/enable' : 1,
        \}, get(g:quickrun_config, 'ruby', {}), "keep")

  " c++
  if executable('clang++')
    let g:quickrun_config['cpp'] = extend({
    \  'type' : 'cpp/clang++',
    \}, get(g:quickrun_config, 'cpp', {}), "keep")
  elseif executable('g++')
    let g:quickrun_config['cpp'] = extend({
    \  'type' : 'cpp/g++',
    \}, get(g:quickrun_config, 'cpp', {}), "keep")
  endif

  " c
  if executable('clang')
    let g:quickrun_config['c'] = extend({
    \  'type' : 'c/clang',
    \}, get(g:quickrun_config, 'c', {}), "keep")
  elseif executable('gcc')
    let g:quickrun_config['c'] = extend({
    \  'type' : 'c/gcc',
    \}, get(g:quickrun_config, 'c', {}), "keep")
  endif

  " typescript
  " from ycino
  " tsc command check run as root
  let g:quickrun_config['typescript/tsc/noemit'] = extend({
    \ 'command': 'tsc',
    \ 'exec': ['%C --project . --noEmit --incremental --tsBuildInfoFile .git/.tsbuildinfo'],
    \ 'outputter' : 'quickfix',
    \ 'outputter/quickfix/errorformat' : '%+A %#%f %#(%l\,%c): %m,%C%m',
    \}, get(g:quickrun_config, 'typescript/tsc/noemit', {}), "keep")

  " shift jis: 'cp932'
  " shift jis: 'cp65001'
  if g:user.system.windows
    for s:typename in s:quickrun_filetype_encode_fixlist
      let g:quickrun_config[s:typename]['hook/output_encode/enable'] = 1
      let g:quickrun_config[s:typename]['hook/output_encode/encoding'] = 'cp932'
      let g:quickrun_config[s:typename]['hook/output_encode/fileformat'] = 'unix'
    endfor
  endif

  function s:vimproc_ok() abort
    let vimproc = 0
    try
      silent call vimproc#version()
      let vimproc = 1
    catch
    endtry

    return vimproc
  endfunction

  function s:runner_setup() abort
    if s:vimproc_ok()
      let g:quickrun_config._['runner'] = 'vimproc'
      let g:quickrun_config._['runner/vimproc/sleep'] = 30
      let g:quickrun_config._['runner/vimproc/updatetime'] = 50
    elseif has('job') || has('nvim')
      if has('nvim')
        let g:quickrun_config._['runner'] = 'neovim_job'
      else
        let g:quickrun_config._['runner'] = 'job'
      endif
    else
      let g:quickrun_config._['runner'] = 'system'
    endif
  endfunction

  augroup vimrc_init-quickrun
    autocmd!
    autocmd VimEnter * nested :call s:runner_setup() | autocmd! vimrc_init-quickrun
  augroup END

  " mapping
  " thanks lambdalisue
  nmap <Leader>qr <Plug>(quickrun)

  " Terminate the quickrun with <C-c>
  nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
'''
hook_post_source = '''
  let s:slash_hook = {
            \ "name" : "slash",
            \ "kind" : "hook",
            \ "config" : {
            \  "enable"     : 0,
            \  "shellslash" : 0,
            \ }
            \}

  function! s:slash_hook.on_hook_loaded(session, context) abort
    if self.config.enable && exists('+shellslash')
      let self.config.shellslash = &shellslash
      set noshellslash
    endif
  endfunction

  function! s:slash_hook.on_exit(session, context) abort
    if self.config.enable && exists('+shellslash')
      let &shellslash = self.config.shellslash
    endif
  endfunction

  call quickrun#module#register(s:slash_hook, 1)
  unlet s:slash_hook

  " :QuickRun ÊôÇ„Å´ quickfix „ÅÆ‰∏≠Ë∫´„Çí„ÇØ„É™„Ç¢„Åô„Çã
  " „Åì„ÅÜ„Åó„Å¶„Åä„Åã„Å™„ÅÑ„Å® quickfix „ÅÆ‰∏≠Ë∫´„ÅåÊÆã„Å£„Åü„Åæ„Åæ„Å´„Å™„Å£„Å¶„Åó„Åæ„ÅÜ„Åü„ÇÅ
  let s:clear_hook = {
            \   "name" : "clear_quickfix",
            \   "kind" : "hook",
            \}

  function! s:clear_hook.on_normalized(session, context)
    call setqflist([])
  endfunction

  call quickrun#module#register(s:clear_hook, 1)
  unlet s:clear_hook

  " thanks ycino
  AlterCommand          r[un] QuickRun
  AlterCommand <cmdwin> r[un] QuickRun
'''

[[plugins]]
repo = 'skywind3000/asyncrun.vim'
depends = ['vital.vim']
hook_post_source = '''
  let s:List     = g:V.import('Data.List')

  let g:asyncrun_rootmarks = s:List.concat([
    \ g:user.rootmarker.dirs,
    \ g:user.rootmarker.files])
  unlet s:List
'''

# UI
# based on https://tmnm.tech/2017/10/11/vim-setting-with-cica/
# need powerline,devicons font
[[plugins]]
repo = 'ryanoasis/vim-devicons'
hook_add = '''
  " „Éï„Ç©„É´„ÉÄ„Ç¢„Ç§„Ç≥„É≥„ÅÆË°®Á§∫„ÇíON
  let g:WebDevIconsUnicodeDecorateFolderNodes = 1

  let g:NERDTreeDirArrowExpandable  = nr2char(0xf0da) " ÔÉö nf-fa-caret_right
  let g:NERDTreeDirArrowCollapsible = nr2char(0xf0d7) " ÔÉó nf-fa-caret_down

  let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols = get(g:, 'WebDevIconsUnicodeDecorateFileNodesExtensionSymbols', {})
  let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['html']     = nr2char(0xe736) " 'Óú∂'
  let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['css']      = nr2char(0xe749) " 'Óùâ'
  let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['markdown'] = nr2char(0xf48a) " 'Ôíä'
  let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['md']       = nr2char(0xf48a) " 'Ôíä'
  let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols['txt']      = nr2char(0xf0f6) " 'ÔÉ∂'

  let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols = get(g:, 'WebDevIconsUnicodeDecorateFileNodesExactSymbols', {})
  let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols['pipfile']      = nr2char(0xe73c) " 'Óúº'
'''

[[plugins]]
repo = 'lambdalisue/nerdfont.vim'
hook_add = '''
  let g:nerdfont#path#extension#customs = get(g:, 'nerdfont#path#extension#customs', {})
  let g:nerdfont#path#extension#customs['html']     = nr2char(0xe736) " 'Óú∂'
  let g:nerdfont#path#extension#customs['css']      = nr2char(0xe749) " 'Óùâ'
  let g:nerdfont#path#extension#customs['markdown'] = nr2char(0xf48a) " 'Ôíä'
  let g:nerdfont#path#extension#customs['md']       = nr2char(0xf48a) " 'Ôíä'
  let g:nerdfont#path#extension#customs['txt']      = nr2char(0xf0f6) " 'ÔÉ∂'

  let g:nerdfont#path#basename#customs = get(g:, 'nerdfont#path#basename#customs', {})
  let g:nerdfont#path#basename#customs['pipfile']   = nr2char(0xe73c) " 'Óúº'
'''

[[plugins]]
repo = 'lambdalisue/glyph-palette.vim'
hook_add = '''
  " custom glyph
  let g:glyph_palette#palette = get(g:, 'glyph_palette#palette', copy(g:glyph_palette#defaults#palette))

  let g:glyph_palette#palette['GlyphPalette3'] += [
    \ nr2char(0xe736),
    \ nr2char(0xe749),
    \ nr2char(0xf48a),
    \ nr2char(0xf0f6),
    \ ]

  augroup vimrc-init_nerdfont
    autocmd!
    autocmd FileType fern     call glyph_palette#apply()
    autocmd FileType startify call glyph_palette#apply()
  augroup END
'''

# currently off
# [[plugins]]
# repo = 'wsdjeg/dein-ui.vim'
# depends = ['dein.vim']
# hook_add = '''
#   let g:spacevim_plugin_manager = 'dein'
#   let g:spacevim_plugin_manager_max_processes = 4
# '''

[[plugins]]
repo = 'haya14busa/dein-command.vim'
depends = ['dein.vim']

[[plugins]]
repo = 'mopp/sky-color-clock.vim'
depends = ['vim-pass']
hook_add = '''
  " Configure variables.
  " let g:sky_color_clock#color_stops
  let g:sky_color_clock#datetime_format = '%m/%d(%a) %H:%M'
  let g:sky_color_clock#enable_emoji_icon = 1
  " let g:sky_color_clock#openweathermap_api_key = "<token>"
  call pass#get_startup('g:sky_color_clock#openweathermap_api_key','Develop/OpenWeatherMap')
  let g:sky_color_clock#temperature_color_stops =  [
            \ [263, '#f0f8ff'],
            \ [288, '#ffffff'],
            \ [313, '#dc143c']
            \ ]

  let g:sky_color_clock#latitude               = g:user.location.latitude
  let g:sky_color_clock#openweathermap_city_id = g:user.location.cityid
'''

# Git
[[plugins]]
repo = 'tpope/vim-git'
hook_add = '''
  let g:gitcommit_cleanup = 'scissors'
'''

[[plugins]]
repo = 'tpope/vim-fugitive'
hook_add = '''
  augroup vimrc_init-fugitive
    autocmd!
    " based on https://qiita.com/yuku_t/items/0c1aff03949cb1b8fe6b
    autocmd QuickFixCmdPost Ggrep nested cwindow
    " see https://vi.stackexchange.com/questions/11502/how-to-execute-a-command-when-leaving-the-fugitiveblame-window
    " autocmd FileType fugitiveblame nnoremap <silent><buffer> q :q<CR>wincmd =
    autocmd FileType fugitiveblame nnoremap <silent><buffer> q :q<CR><C-W>=
  augroup END
'''

[[plugins]]
repo = 'tpope/vim-rhubarb'
depends = ['vim-fugitive','vim-pass']
# on_if= 'executable("hub")'
hook_add = '''
  " github token
  call pass#get_startup('g:RHUBARB_TOKEN','Develop/Github')
'''
hook_post_source = '''
  autocmd MyAutoGroup Filetype gitcommit,gitrebase nested
    \ setlocal omnifunc=rhubarb#omnifunc
'''

[[plugins]] # git log show
repo = 'junegunn/gv.vim'
depends = ['vim-fugitive']
hook_add = '''
'''

[[plugins]]
repo = 'idanarye/vim-merginal'
depends = ['vim-fugitive']

[[plugins]]
repo = 'cohama/agit.vim'
# on_if= 'executable("git")'

[[plugins]]
repo = 'lambdalisue/gina.vim'
# on_if= 'executable("git")'

[[plugins]]
repo = 'rhysd/git-messenger.vim'

[[plugins]] # git commit
repo = 'teddywing/vim-gitcha'

[[plugins]] # git rebase
repo = 'hotwatermorning/auto-git-diff'
hook_add = '''
  let g:auto_git_diff_command_options = '--stat -p --submodule -C'
'''
hook_post_source = '''
  function! s:setup_auto_git_diff() abort
    nmap <buffer><C-l> <Plug>(auto_git_diff_scroll_manual_update)
    nmap <buffer><C-n> <Plug>(auto_git_diff_scroll_down_half)
    nmap <buffer><C-p> <Plug>(auto_git_diff_scroll_up_half)
  endfunction
  augroup vimrc_init-auto-git-diff
    autocmd!
    autocmd FileType gitrebase nested call <SID>setup_auto_git_diff()
  augroup END
'''

[[plugins]]
repo = 'mhinz/vim-signify'
hook_add = '''
  let g:signify_sign_add               = nr2char(0x271a) " '‚úö'
  let g:signify_sign_change            = nr2char(0x279c) " '‚ûú'
  let g:signify_sign_delete            = nr2char(0x2718) " '‚úò'
  let g:signify_sign_delete_first_line = nr2char(0x2717) " '‚úó'

  " highlight line
  " let g:signify_line_highlight = 1
'''
hook_post_source = '''
  " Need a quick update updatetime
  set updatetime=200

  " highlight SignifySignAdd       guifg=#009900 guibg=<X> ctermfg=2 ctermbg=<Y>
  " highlight SignifySignChange    guifg=#bbbb00 guibg=<X> ctermfg=3 ctermbg=<Y>
  " highlight SignifySignDelete    guifg=#ff2222 guibg=<X> ctermfg=1 ctermbg=<Y>
  " highlight                      gui=underlined term=underlined cterm=underlined
  " highlight SignifySignDeleteFirstLine
  " highlight link SignifySignDeleteFirstLine SignifySignDelete

  nnoremap <silent> <Leader>hp :<C-u>SignifyHunkDiff<cr>
  nnoremap <silent> <Leader>hu :<C-u>SignifyHunkUndo<cr>
  " nnoremap <silent> <Leader>hs :<cr>    " staging
'''

[[plugins]]
repo = 'gotchane/vim-git-commit-prefix'

[[plugins]]
repo = 'rhysd/conflict-marker.vim'
hook_add = '''
  " disable the default highlight group
  let g:conflict_marker_highlight_group = ''

  " Include text after begin and end markers
  let g:conflict_marker_begin = '^<<<<<<< .*$'
  let g:conflict_marker_end   = '^>>>>>>> .*$'

  highlight ConflictMarkerBegin guibg=#2f7366
  highlight ConflictMarkerOurs guibg=#2e5049
  highlight ConflictMarkerTheirs guibg=#344f69
  highlight ConflictMarkerEnd guibg=#2f628e
'''

# self create plugin statusline updater
[[plugins]]
repo  = 'tsuyoshicho/StatuslineUpateTimer.vim'
hook_add = '''
  " update evenly 15sec
  let g:StatuslineUpdateTimer#updatetime = 15 * 1000

  " set adjust
  let g:StatuslineUpdateTimer#adjust_minute = 1
'''

[[plugins]]
repo  = 'KabbAmine/vCoolor.vim'

[[plugins]]
repo = 'itchyny/lightline.vim'
hook_add = '''
  " lightline setting in lightline-delphinus
  " debug
  " let g:lightline = {}
  " breakadd expr g:lightline
'''
hook_post_source = '''
'''

[[plugins]]
repo = 'taohexxx/lightline-buffer'
depends = ['lightline.vim', 'vim-devicons']
hook_add = '''
  " lightline-buffer setting in lightline-delphinus

  " lightline-buffer ui settings
  " replace these symbols with ascii characters if your environment does not support unicode
  let g:lightline_buffer_logo = nr2char(0xe7c5)  " original 'Ô£ø '
  let g:lightline_buffer_readonly_icon = 'ÓÇ¢'
  let g:lightline_buffer_modified_icon = '‚≠ê'
  let g:lightline_buffer_git_icon = 'ÓÇ† '
  let g:lightline_buffer_ellipsis_icon = '..'
  let g:lightline_buffer_expand_left_icon = '‚óÄ '
  let g:lightline_buffer_expand_right_icon = ' ‚ñ∂'
  " let g:lightline_buffer_active_buffer_left_icon = '‚¨ÖÔ∏è'
  " let g:lightline_buffer_active_buffer_right_icon = '‚û°Ô∏è'
  " let g:lightline_buffer_separator_icon = '  '

  " enable devicons, only support utf-8
  " require <https://github.com/ryanoasis/vim-devicons>
  let g:lightline_buffer_enable_devicons = 1

  " lightline-buffer function settings
  let g:lightline_buffer_show_bufnr = 1

  " :help filename-modifiers
  " let g:lightline_buffer_fname_mod = ':t'
  let g:lightline_buffer_fname_mod = ':p:~'

  " " hide buffer list
  " let g:lightline_buffer_excludes = ['vimfiler']
  "
  " " max file name length
  " let g:lightline_buffer_maxflen = 30
  "
  " " max file extension length
  " let g:lightline_buffer_maxfextlen = 3
  "
  " " min file name length
  " let g:lightline_buffer_minflen = 16
  "
  " " min file extension length
  " let g:lightline_buffer_minfextlen = 3
  "
  " reserve length for other component (e.g. info, close)
  let g:lightline_buffer_reservelen = 30
'''
hook_post_source = '''
  " need lightline-buffer
  set showtabline=2 " Â∏∏„Å´„Çø„Éñ„É©„Ç§„É≥„ÇíË°®Á§∫
  set hidden        " „Éê„ÉÉ„Éï„Ç°„ÅåÁ∑®ÈõÜ‰∏≠„Åß„ÇÇ„Åù„ÅÆ‰ªñ„ÅÆ„Éï„Ç°„Ç§„É´„ÇíÈñã„Åë„Çã„Çà„ÅÜ„Å´

  " " remap arrow keys
  " nnoremap <silent> <Left>  :bprev<CR>
  " nnoremap <silent> <Right> :bnext<CR>
  " nnoremap <silent> <C-Left>  :tabprevious<CR>
  " nnoremap <silent> <C-Right> :tabnext<CR>

  " current lightline-buffer off
  " gui use text tabline
  " if has('gui_running')
  "   set guioptions-=e
  " endif
'''

[[plugins]]
repo = 'tsuyoshicho/lightline-lsp'
depends = ['lightline.vim']
hook_add = '''
  let g:lightline#lsp#server_interval = 60

  if has('gui_running')
    let g:lightline#lsp#indicator_checking = "\uf110"
    let g:lightline#lsp#indicator_warning = "\uf071"
    let g:lightline#lsp#indicator_error = "\uf05e"
    let g:lightline#lsp#indicator_information = "\uf05a"
    let g:lightline#lsp#indicator_hint = "\uf0e5"
    let g:lightline#lsp#indicator_ok = "\uf00c"
  endif
'''

# lightline setting use lightline-delphinus
# based on https://qiita.com/delphinus/items/af5809b587f2af0a9f7f
[[plugins]]
repo = 'delphinus/lightline-delphinus'
# repo = 'tsuyoshicho/lightline-delphinus'
# rev  = 'develop'
depends = ['lightline.vim', 'lightline-buffer', 'vim-devicons', 'vim-anzu', 'vim-submode', 'lightline-lsp', 'vista.vim', 'vim-signify', 'gina.vim', 'StatuslineUpateTimer.vim']
# Ë®≠ÂÆö„Åô„Çã„Éï„Ç©„É≥„Éà„ÅØ powerline patched
hook_add = '''
  let g:lightline_delphinus_use_powerline_glyphs = 1
  let g:lightline_delphinus_use_nerd_fonts_glyphs = 1
  let g:lightline_delphinus_colorscheme = 'solarized_improved'
  " let g:lightline_delphinus_colorscheme = 'nord_improved'
'''
hook_post_source = '''
  " enable setting
  " let g:lightline_delphinus_tagbar_enable = 1
  " let g:lightline_delphinus_gitgutter_enable = 1
  let g:lightline_delphinus_signify_enable = 1

  function! Lightline_components_gina() abort
    if &buftype ==# 'terminal' || &filetype =~# 'denite' || winwidth(0) < 100
      return ''
    endif
    try
      if g:lightline_delphinus_use_powerline_glyphs
        let s:branch_glyph = "\ue0a0" " ÓÇ†
      else
        let s:branch_glyph = ''
      endif
      if &filetype !~? 'vimfiler\|gundo\|tagbar'
        let head = gina#component#repo#branch()
        if head !=? ''
          let head = s:branch_glyph . head
        endif
        return head
      endif
    catch
    endtry
    return ''
  endfunction

  let g:lightline = {
    \ 'colorscheme': g:lightline_delphinus_colorscheme,
    \ 'active': {
    \   'left' : [
    \     [ 'mode', 'paste' ],
    \     [ 'gitbranch', 'signify', 'lsp_count'],
    \     [ 'filepath' ],
    \     [ 'filename', 'method', 'lsp_status_ok', 'lsp_status_error', 'lsp_status_warning']
    \   ],
    \   'right': [
    \     [ 'sky_color_clock' ],
    \     [ 'lineinfo', 'percent', 'anzu', 'submode' ],
    \     [ 'fileformat', 'fileencoding', 'filetype' ],
    \     [ 'char_code' ],
    \   ],
    \ },
    \ 'inactive': {
    \   'left'  : [ [ 'filepath' ], [ 'filename' ] ],
    \   'right' : [ [ 'sky_color_clock' ], [ 'lineinfo' ], [ 'percent' ] ],
    \ },
    \ 'component': {
    \   'sky_color_clock' : "%#SkyColorClock#%{' ' . sky_color_clock#statusline() . ' ' .  StatuslineUpdateTimer#emoji_clock() . ' '}%#SkyColorClockTemp# ",
    \   'separator'       : nr2char(0xff9e8),
    \ },
    \ 'component_function': {
    \   'modified':     'lightline#delphinus#components#modified',
    \   'readonly':     'lightline#delphinus#components#readonly',
    \   'fugitive':     'lightline#delphinus#components#fugitive',
    \   'filepath':     'lightline#delphinus#components#filepath',
    \   'filename':     'lightline#delphinus#components#filename',
    \   'fileformat':   'lightline#delphinus#components#fileformat',
    \   'filetype':     'lightline#delphinus#components#filetype',
    \   'fileencoding': 'lightline#delphinus#components#fileencoding',
    \   'mode':         'lightline#delphinus#components#mode',
    \   'char_code':    'lightline#delphinus#components#charcode',
    \   'lineinfo':     'lightline#delphinus#components#lineinfo',
    \   'percent':      'lightline#delphinus#components#percent',
    \   'currenttag':   'lightline#delphinus#components#currenttag',
    \   'gitgutter':    'lightline#delphinus#components#gitgutter',
    \   'signify':      'lightline#delphinus#components#signify',
    \   'lsp_count':    'lightline#lsp#count',
    \   'method':       'NearestMethodOrFunction',
    \   'anzu':         'anzu#search_status',
    \   'gitbranch':    'Lightline_components_gina',
    \   'submode':      'submode#current',
    \   'bufferinfo':   'lightline#buffer#bufferinfo',
    \ },
    \ 'component_function_visible_condition': {
    \   'mode': 1,
    \   'currenttag': 0,
    \   'char_code': 0,
    \   'fileformat': 0,
    \   'filetype': 0,
    \   'fileencoding': 0,
    \ },
    \ 'component_expand': {
    \   'lsp_status_error':   'lightline#lsp#status_error',
    \   'lsp_status_warning': 'lightline#lsp#status_warning',
    \   'lsp_status_ok':      'lightline#lsp#status_ok',
    \   'buffercurrent':      'lightline#buffer#buffercurrent',
    \   'bufferbefore':       'lightline#buffer#bufferbefore',
    \   'bufferafter':        'lightline#buffer#bufferafter',
    \ },
    \ 'component_type': {
    \   'lsp_status_error':     'error',
    \   'lsp_status_warning':   'warning',
    \   'lsp_status_ok':        'ok',
    \   'buffercurrent': 'tabsel',
    \   'bufferbefore':  'raw',
    \   'bufferafter':   'raw',
    \ },
    \ 'component_raw': {
    \    'sky_color_clock': 1,
    \ },
    \ 'separator': { 'left': nr2char(0xe0b0), 'right': nr2char(0xe0b2) },
    \ 'subseparator': { 'left': nr2char(0xe0b1), 'right': nr2char(0xe0b3) },
    \ 'tabline': {
    \   'left'  : [ [ 'bufferinfo' ],
    \               [ 'separator' ],
    \               [ 'bufferbefore', 'buffercurrent', 'bufferafter' ], ],
    \   'right' : [ [ 'close' ], ],
    \ },
    \}

  " lightline-buffer mix-safety
  " \ 'tabline': {
  " \   'left'  : [ [ 'bufferinfo' ],
  " \               [ 'separator' ],
  " \               [ 'tabs' ], ],
  " \   'right' : [ [ 'close' ], ],
  " \ },
  " lightline-buffer native
  " \ 'tabline': {
  " \   'left'  : [ [ 'bufferinfo' ],
  " \               [ 'separator' ],
  " \               [ 'bufferbefore', 'buffercurrent', 'bufferafter' ], ],
  " \   'right' : [ [ 'close' ], ],
  " \ },

  " colorscheme setting in night-and-day

  " force re-init
  call lightline#init()
  call lightline#colorscheme()
  call lightline#update()
'''

[[plugins]]
# repo = 'nightsense/night-and-day'
repo = 'tsuyoshicho/night-and-day'
# rev  = 'develop'
rev  = 'feature/autoload'
merged = 0
depends = ['lightline-delphinus']
hook_add = '''
  " " colorscheme Âá¶ÁêÜ - ÂøÖË¶Å„Å™‰æùÂ≠òÈñ¢‰øÇ„ÅØÂá¶ÁêÜ„Åô„Çã„Åì„Å®
  " if has('gui_running')
  "   " set background=light
  "   set background=dark
  "   augroup vimrc_init-night-and-day
  "     autocmd!
  "     autocmd VimEnter * nested colorscheme gruvbox | autocmd! vimrc_init-night-and-day
  "   augroup END
  " else
  "   " set background=light
  "   " iceberg„ÅØdarkÂõ∫ÂÆö
  "   set background=dark
  "   augroup vimrc_init-night-and-day
  "     autocmd!
  "     autocmd VimEnter * nested colorscheme iceberg | autocmd! vimrc_init-night-and-day
  "   augroup END
  " endif

  " g:nd_themes setting template
  if has('gui_running')
    let g:nd_themes = [
      \ ['sunrise+0', 'iceberg',          'light', 'iceberg'],
      \ ['sunset+0',  'tokyonight',       'dark',  'tokyonight'],
      \]
  else
    let g:nd_themes = [
      \ ['sunrise+0',   'rigel',            'dark',  'rigel'],
      \ ['sunset+0',    'tokyonight',       'dark',  'tokyonight'],
      \]
  endif

  let g:nd_latitude  = '30' " Asia/Tokyo 35
  let g:nd_timeshift =  '0' " shift minutes

  " " debug
  " let g:nd_themes = [
  "     \ ['09:00', 'gruvbox', 'dark', 'gruvbox'],
  "     \ ['18:12', 'iceberg', 'dark', 'iceberg'],
  "     \]

  let g:nd_lightline = 1
'''

# Edit operation
# [[plugins]]
# repo = 'matze/vim-move'
# depends = ['vim-submode']
# hook_add = '''
#   " default map disable
#   let g:move_map_keys = 0
#   " setting with submode
#
#   " indent adjust?
#   let g:move_auto_indent = 0
#   " endofline limit? -> nolimit
#   let g:move_past_end_of_line = 1
# '''
# hook_post_source = '''
#   " normal mode line move
#   call submode#enter_with('linemove', 'n', 'r', 'Mj', '<Plug>MoveLineDown')
#   call submode#enter_with('linemove', 'n', 'r', 'Mk', '<Plug>MoveLineUp')
#   call submode#leave_with('linemove', 'n', 'r', '<Esc>')
#   call submode#map('linemove', 'n', 'r', 'j', '<Plug>MoveLineDown')
#   call submode#map('linemove', 'n', 'r', 'k', '<Plug>MoveLineUp')
#
#   " visual mode block move
#   call submode#enter_with('blockmove', 'x', 'r', 'Mj', '<Plug>MoveBlockDown')
#   call submode#enter_with('blockmove', 'x', 'r', 'Mk', '<Plug>MoveBlockUp')
#   call submode#enter_with('blockmove', 'x', 'r', 'Mh', '<Plug>MoveBlockLeft')
#   call submode#enter_with('blockmove', 'x', 'r', 'Ml', '<Plug>MoveBlockRight')
#   call submode#leave_with('blockmove', 'x', 'r', '<Esc>')
#   call submode#map('blockmove', 'x', 'r', 'j', '<Plug>MoveBlockDown')
#   call submode#map('blockmove', 'x', 'r', 'k', '<Plug>MoveBlockUp')
#   call submode#map('blockmove', 'x', 'r', 'h', '<Plug>MoveBlockLeft')
#   call submode#map('blockmove', 'x', 'r', 'l', '<Plug>MoveBlockRight')
# '''

[[plugins]]
repo = 't9md/vim-textmanip'
depends = ['vim-submode']
hook_add = '''
  " default map disable(default)
  let g:textmanip_enable_mappings = 0

  let g:textmanip_move_ignore_shiftwidth = 1
'''
hook_post_source = '''
  " visual mode move
  call submode#enter_with('blockmove', 'x', 'r', 'Mk', '<Plug>(textmanip-move-up)'   )
  call submode#enter_with('blockmove', 'x', 'r', 'Mj', '<Plug>(textmanip-move-down)' )
  call submode#enter_with('blockmove', 'x', 'r', 'Mh', '<Plug>(textmanip-move-left)' )
  call submode#enter_with('blockmove', 'x', 'r', 'Ml', '<Plug>(textmanip-move-right)')
  call submode#leave_with('blockmove', 'x', 'r', '<Esc>')
  call submode#map('blockmove', 'x', 'r', 'k', '<Plug>(textmanip-move-up)'   )
  call submode#map('blockmove', 'x', 'r', 'j', '<Plug>(textmanip-move-down)' )
  call submode#map('blockmove', 'x', 'r', 'h', '<Plug>(textmanip-move-left)' )
  call submode#map('blockmove', 'x', 'r', 'l', '<Plug>(textmanip-move-right)')
  call submode#map('blockmove', 'x', 'r', 't', '<Plug>(textmanip-toggle-mode)')
'''

[[plugins]]
repo = 'tyru/columnskip.vim'
hook_post_source = '''
  " like tmhedberg/indent-motion
  map mk <Plug>(columnskip:nonblank:prev)
  map mj <Plug>(columnskip:nonblank:next)

  map mK <Plug>(columnskip:first-nonblank:prev)
  map mJ <Plug>(columnskip:first-nonblank:next)
'''

# [[plugins]]
# repo = 'haya14busa/vim-edgemotion'
# hook_post_source = '''
#   " map <C-j> <Plug>(edgemotion-j)
#   " map <C-k> <Plug>(edgemotion-k)
#
#   map <Leader><C-j> <Plug>(edgemotion-j)
#   map <Leader><C-k> <Plug>(edgemotion-k)
# '''

[[plugins]]
repo = 'bronson/vim-trailing-whitespace'
hook_add = '''
  let g:extra_whitespace_ignored_filetypes =
    \ ['markdown', 'startify', 'nerdtree', 'tagbar', 'unite', 'fern']
'''

[[plugins]]
repo = 'lambdalisue/trimmer.vim'

[[plugins]]
repo = 'thinca/vim-zenspace'
hook_post_source = '''
  " https://qiita.com/tmsanrinsha/items/d6c11f2b7788eb24c776

  " add non zenspace (UCS spaces)
  augroup vimrc_init-zenspace
    autocmd!
    autocmd VimEnter,WinEnter * nested match ZenSpace /\%u180E\|\%u2000\|\%u2001\|\%u2002\|\%u2003\|\%u2004\|\%u2005\|\%u2006\|\%u2007\|\%u2008\|\%u2009\|\%u200A\|\%u2028\|\%u2029\|\%u202F\|\%u205F\|\%u3000/
  augroup END
'''

[[plugins]]
repo = 'junegunn/goyo.vim'
hook_post_source = '''
  " currently, statusline update and enter/leave (rel)number
  " manipulation conflict.
  nnoremap <silent> <F12> :Goyo<CR>
'''

[[plugins]]
repo = 'junegunn/limelight.vim'
hook_add = '''
  if !has("gui_running")
    " Color name (:help cterm-colors) or ANSI code
    let g:limelight_conceal_ctermfg = 'gray'
    let g:limelight_conceal_ctermfg = 240
  else
    " Color name (:help gui-colors) or RGB color
    let g:limelight_conceal_guifg = 'DarkGray'
    let g:limelight_conceal_guifg = '#777777'
  endif

  " Default: 0.5
  " let g:limelight_default_coefficient = 0.7

  " Number of preceding/following paragraphs to include (default: 0)
  " let g:limelight_paragraph_span = 1

  " Beginning/end of paragraph
  "   When there's no empty line between the paragraphs
  "   and each paragraph starts with indentation
  " let g:limelight_bop = '^\s'
  " let g:limelight_eop = '\ze\n^\s'

  " Highlighting priority (default: 10)
  "   Set it to -1 not to overrule hlsearch
  " let g:limelight_priority = -1
'''
hook_post_source = '''
  " with Goyo
  autocmd! MyAutoGroup User GoyoEnter Limelight
  autocmd! MyAutoGroup User GoyoLeave Limelight!
'''

[[plugins]]
# repo = 'nathanaelkane/vim-indent-guides'
repo = 'Bakudankun/vim-indent-guides'
hook_add = '''
  " based on https://wonderwall.hatenablog.com/entry/2016/03/21/205741
  " based on https://qiita.com/Layzie/items/a1c8d14bccb14c02eb1b
  " vim„ÇíÁ´ã„Å°‰∏ä„Åí„Åü„Å®„Åç„Å´„ÄÅËá™ÂãïÁöÑ„Å´vim-indent-guides„Çí„Ç™„É≥„Å´„Åô„Çã
  let g:indent_guides_enable_on_vim_startup = 1

  let g:indent_guides_start_level = 2

  let g:indent_guides_guide_size = 1

  " ÁÑ°Âäπ„Å´„Åó„Åü„ÅÑ„Éï„Ç°„Ç§„É´„Çø„Ç§„Éó
  let g:indent_guides_exclude_filetypes = [
    \ 'help', 'startify', 'nerdtree', 'tagbar', 'unite', 'vista', 'json'
    \ ]

  " „Éû„ÉÉ„Éî„É≥„Ç∞„ÅØ‰Ωø„Çè„Å™„ÅÑ
   let g:indent_guides_default_mapping = 0
'''

# # exclusive : need indent-guide off
# [[plugins]]
# repo = 'Yggdroot/indentLine'
# hook_add = '''
#   " enable
#   " let g:indentLine_enabled = 0
#   let g:indentLine_enabled = 1
#
#   " need UTF-8 ‚îÜ U+2506
#   " let g:indentLine_first_char = '‚îÜ'
#   " let g:indentLine_char       = '‚îÜ'
#   " need UTF-8 ‚¶ô U+299A
#   let g:indentLine_first_char = '‚¶ô'
#   let g:indentLine_char       = '‚¶ô'
#   " need patched font : Óò° nf-indent-line / e621
#   " let g:indentLine_first_char = nr2char(0xe621)
#   " let g:indentLine_char       = nr2char(0xe621)
#
#   " no conceal for edit
#   let g:indentLine_fileTypeExclude = ['startify', 'json']
#   let g:indentLine_bufTypeExclude  = ['help', 'terminal']
#
#   " conceallevel/concealcursor set in vimrc
#   let g:indentLine_setConceal = 0
# '''
# hook_post_source = '''
#   " based on http://d.hatena.ne.jp/osyo-manga/20140722/1406040828
#   augroup vimrc_init-indentLine
#     autocmd!
#     " precious.vim „Åå filetype „ÇíÂàá„ÇäÊõø„Åà„ÇãÂ∫¶„Å´ indentLine „Çí„É™„Çª„ÉÉ„Éà„Åô„Çã
#     autocmd User PreciousFileType IndentLinesReset
#   augroup END
# '''

# commentout
[[plugins]]
repo = 'tyru/caw.vim'
depends = ['vim-operator-user', 'vim-repeat']
# operator-user : mapping improve
# repeat        : repeat action work fine

# latest vim support auto bracket
# [[plugins]]
# repo = 'ConradIrwin/vim-bracketed-paste'

[[plugins]]
repo = 'tweekmonster/braceless.vim'
hook_add = '''
  augroup vimrc_init-braceless
    autocmd!
    autocmd FileType python           nested BracelessEnable +indent
    autocmd FileType haml,yaml,coffee nested BracelessEnable +indent +fold +highlight
  augroup END
'''

[[plugins]]
repo = 'editorconfig/editorconfig-vim'
# repo = 'sgur/vim-editorconfig'
hook_add = '''
  " editorconfig/editorconfig-vim
  let g:EditorConfig_exclude_patterns = ['fugitive://.\*', 'scp://.\*']

  " sgur/vim-editorconfig
  " editorconfig root„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åù„Åì„ÇíËµ∑ÁÇπ„Å®„Åó„ÅüÁõ∏ÂØæÂá¶ÁêÜ„Å´„Åô„Çã
  " let g:editorconfig_root_chdir = 1 " default:0
'''

[[plugins]]
repo = 'mattn/vim-sonictemplate'
hook_add = '''
  " user template
  let g:sonictemplate_vim_template_dir = expand(g:user.dir.config_home . '/template')
  call g:user.function.mkdir(g:sonictemplate_vim_template_dir)

  " always my name
  let g:sonictemplate_vim_vars = {
  \ '_': {
  \   'author': g:user.name,
  \ },
  \}
'''

[[plugins]]
repo = 'andymass/vim-matchup'
hook_add = '''
  " let g:matchup_matchparen_enabled = 0
  " if use parenmatch
  " deliver text object a%/i%
'''

[[plugins]] # paren match rainbow
repo = 'luochen1990/rainbow'
hook_add = '''
  let g:rainbow_active = 1 "0 if you want to enable it later via :RainbowToggle

  let g:rainbow_conf = {
    \ 'separately': {
    \   'cpp': {
    \     'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/\</ end=/\>/ fold','start=/{/ end=/}/ fold'],
    \   },
    \   'markdown': {
    \     'parentheses_options': 'containedin=markdownCode contained',
    \   },
    \   'vim': {
    \     'parentheses_options': 'containedin=vimFuncBody',
    \   },
    \   'css': 0,
    \ },
    \}
'''

[[plugins]]
repo = 't9md/vim-quickhl'
hook_add = '''
  let g:quickhl_manual_enable_at_startup = 1
  " normally work itchyny/vim-cursorword
  let g:quickhl_cword_enable_at_startup  = 0
  " currently not work yet.
  let g:quickhl_tag_enable_at_startup    = 0

  let g:quickhl_manual_keywords = [
  \  { 'pattern': '\c\<tsuyoshi[._ ]\?cho\>',          'regexp': 1 },
  \  { 'pattern': '\C\<\(TODO\|FIXME\|NOTE\|INFO\)\>', 'regexp': 1 },
  \  { 'pattern': '\C\<\(ToC\|WIP\)\>',                'regexp': 1 },
  \]
'''
hook_post_source = '''
  nmap <Space>m <Plug>(quickhl-manual-this)
  xmap <Space>m <Plug>(quickhl-manual-this)
  nmap <Space>M <Plug>(quickhl-manual-reset)
  xmap <Space>M <Plug>(quickhl-manual-reset)

  nmap <Space>j <Plug>(quickhl-cword-toggle)
  " nmap <Space>] <Plug>(quickhl-tag-toggle)
'''

[[plugins]]
repo = 'cohama/lexima.vim'
hook_add = '''
  let g:lexima_no_default_rules = 1

  let g:lexima_enable_basic_rules = 1
  let g:lexima_enable_newline_rules = 1
  let g:lexima_enable_space_rules = 1
  let g:lexima_enable_endwise_rules = 1

  " self process define : need abnormal completion process(like asyncomplete)
  " let g:lexima_accept_pum_with_enter = 0
'''
hook_post_source = '''
  call lexima#set_default_rules()

  let s:cr_key = '<CR>'
  " suport plantuml,...
  let s:additional_rules = [
        \ {
        \   'char': '<CR>',
        \   'input': s:cr_key,
        \   'input_after': '<CR>' . '@enduml',
        \   'at': '\%(^\s*#.*\)\@<!@startuml\>.*\%#',
        \   'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' . '\@enduml',
        \   'filetype': ['plantuml'],
        \   'syntax': [],
        \ },
        \ {
        \   'char': '<CR>',
        \   'input': s:cr_key,
        \   'input_after': '<CR>' . '@endgantt',
        \   'at': '\%(^\s*#.*\)\@<!@startgantt\>.*\%#',
        \   'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' . '\@endgantt',
        \   'filetype': ['plantuml'],
        \   'syntax': [],
        \ },
        \ {
        \   'char': '<CR>',
        \   'input': s:cr_key,
        \   'input_after': '<CR>' . '@endditaa',
        \   'at': '\%(^\s*#.*\)\@<!@startditaa\>.*\%#',
        \   'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' . '\@endditaa',
        \   'filetype': ['plantuml'],
        \   'syntax': [],
        \ },
        \ {
        \   'char': '<CR>',
        \   'input': s:cr_key,
        \   'input_after': '<CR>' . '@enddot',
        \   'at': '\%(^\s*#.*\)\@<!@startdot\>.*\%#',
        \   'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' . '\@enddot',
        \   'filetype': ['plantuml'],
        \   'syntax': [],
        \ },
        \ {
        \   'char': '<CR>',
        \   'input': s:cr_key,
        \   'input_after': '<CR>' . '@endsalt',
        \   'at': '\%(^\s*#.*\)\@<!@startsalt\>.*\%#',
        \   'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' . '\@endsalt',
        \   'filetype': ['plantuml'],
        \   'syntax': [],
        \ },
        \ {
        \   'char': '<CR>',
        \   'input': s:cr_key,
        \   'input_after': '<CR>' . '@endwbs',
        \   'at': '\%(^\s*#.*\)\@<!@startwbs\>.*\%#',
        \   'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' . '\@endwbs',
        \   'filetype': ['plantuml'],
        \   'syntax': [],
        \ },
        \ {
        \   'char': '<CR>',
        \   'input': s:cr_key,
        \   'input_after': '<CR>' . '@endmindmap',
        \   'at': '\%(^\s*#.*\)\@<!@startmindmap\>.*\%#',
        \   'except': '\C\v^(\s*)\S.*%#\n%(%(\s*|\1\s.+)\n)*\1' . '\@endmindmap',
        \   'filetype': ['plantuml'],
        \   'syntax': [],
        \ },
        \]

  for s:rule in s:additional_rules
    call lexima#add_rule(s:rule)
  endfor

  " rule from https://github.com/rinx/dotfiles/blob/master/vimrc
  " markdown
  call lexima#add_rule({'char': '**', 'input_after': '**', 'filetype': ['markdown']})
  call lexima#add_rule({'char': '<BS>', 'at': '\*\%#\*', 'delete': 1, 'filetype': ['markdown']})
  call lexima#add_rule({'char': '__', 'input_after': '__', 'filetype': ['markdown']})
  call lexima#add_rule({'char': '<BS>', 'at': '_\%#_', 'delete': 1, 'filetype': ['markdown']})
  call lexima#add_rule({'char': '~~', 'input_after': '~~', 'filetype': ['markdown']})
  call lexima#add_rule({'char': '<BS>', 'at': '\~\%#\~', 'delete': 1, 'filetype': ['markdown']})
  call lexima#add_rule({'char': '<CR>', 'at': '^\s*\*\s.*\%#', 'input': '<CR>* ', 'filetype': ['markdown']})
  call lexima#add_rule({'char': '<CR>', 'at': '^\s*+\s.*\%#', 'input': '<CR>+ ', 'filetype': ['markdown']})
  call lexima#add_rule({'char': '<CR>', 'at': '^\s*-\s.*\%#', 'input': '<CR>- ', 'filetype': ['markdown']})
  " from https://github.com/cohama/.vim/blob/master/dein.toml
  " call lexima#add_rule({'char': '<CR>', 'at': '^```\(\S*\)\%#```', 'input': '<C-y><CR><CR><Esc>kS', 'filetype': ['markdown']})

  " vimspec
  " from https://github.com/cohama/.vim/blob/master/dein.toml
  call lexima#add_rule({'char': '<CR>', 'at': '^\s*\%(Describe\|Context\|It\|Before\|After\)\s\+.*\%#',
  \   'input_after': '<CR>End', 'filetype': ['vimspec']})

  " vim, vimspec
  " from https://github.com/cohama/.vim/blob/master/dein.toml
  " custom
  " ignore stype ["String", "Comment"]
  " vimspec support
  " [] support
  call lexima#add_rule({'at': '{\%#}', 'char': '<CR>', 'input': '<CR><Bslash> ',
    \ 'input_after': '<CR><Bslash> ', 'filetype': ['vim', 'vimspec']})
  call lexima#add_rule({'at': '\[\%#\]', 'char': '<CR>', 'input': '<CR><Bslash> ',
    \ 'input_after': '<CR><Bslash> ', 'filetype': ['vim', 'vimspec']})
  call lexima#add_rule({'at': '\\\s.*\%#$', 'char': '<CR>', 'input': '<CR><Bslash> ',
    \                                 'filetype': ['vim', 'vimspec']})

  " http://secret-garden.hatenablog.com/entry/2015/05/21/194914
  " http://secret-garden.hatenablog.com/entry/2015/05/06/211712

  " keymapping
  " see https://qiita.com/yami_beta/items/26995a5c382bd83ac38f
  inoremap <C-l> <C-r>=lexima#insmode#leave(1, '<LT>C-G>U<LT>RIGHT>')<CR>

  " popup support CR/space(If completion popup is exists, decision completion)
  " add_rules overwrite CR/space mapping

  " move to vimrc
'''

# [[plugins]]
# repo = 'deathlyfrantic/lexima-template-rules'
# depends = ['lexima.vim']

# ‰∏äÊâã„ÅèÂãï„Åã„Å™„ÅÑ
# [[plugins]]
# repo = 'dkarter/bullets.vim'
# hook_add = '''
#   " key map conflict
#   " let g:bullets_set_mappings = 0
#   let g:bullets_mapping_leader = '<C-:>'
#
#   let g:bullets_enable_in_empty_buffers = 1
#   " let g:bullets_enabled_file_types = ['markdown', 'text', 'gitcommit']
# '''

[[plugins]]
repo = 'justinmk/vim-gtfo'

# [[plugins]]
# repo = 'deris/vim-shot-f'

# [[plugins]]
# repo = 'rhysd/clever-f.vim'
# hook_add = '''
#   " let g:clever_f_ignore_case           = 1
#   let g:clever_f_smart_case            = 1
#   let g:clever_f_use_migemo            = 1
#   let g:clever_f_fix_key_direction     = 1
#   let g:clever_f_chars_match_any_signs = ";:"
#
#   let g:clever_f_not_overwrites_standard_mappings = 1
# '''
# hook_post_source = '''
#     nmap f <Plug>(clever-f-f)
#     xmap f <Plug>(clever-f-f)
#     omap f <Plug>(clever-f-f)
#     nmap F <Plug>(clever-f-F)
#     xmap F <Plug>(clever-f-F)
#     omap F <Plug>(clever-f-F)
#     " t use tab
#     " nmap t <Plug>(clever-f-t)
#     " xmap t <Plug>(clever-f-t)
#     " omap t <Plug>(clever-f-t)
#     " nmap T <Plug>(clever-f-T)
#     " xmap T <Plug>(clever-f-T)
#     " omap T <Plug>(clever-f-T)
# '''

[[plugins]]
repo = 'hrsh7th/vim-eft'
hook_add = '''
  let g:eft_ignorecase = v:true
'''
hook_post_source = '''
  nmap ; <Plug>(eft-repeat)
  xmap ; <Plug>(eft-repeat)

  nmap f <Plug>(eft-f-repeatable)
  xmap f <Plug>(eft-f-repeatable)
  omap f <Plug>(eft-f-repeatable)
  nmap F <Plug>(eft-F-repeatable)
  xmap F <Plug>(eft-F-repeatable)
  omap F <Plug>(eft-F-repeatable)
  " t use tab
  " nmap t <Plug>(eft-t-repeatable)
  " xmap t <Plug>(eft-t-repeatable)
  " omap t <Plug>(eft-t-repeatable)
  " nmap T <Plug>(eft-T-repeatable)
  " xmap T <Plug>(eft-T-repeatable)
  " omap T <Plug>(eft-T-repeatable)
'''

[[plugins]]
repo = 'bkad/CamelCaseMotion'
hook_post_source = '''
  map <Leader>c [CamelCaseMotion]
  " normal/operator/visual only / no work select
  nmap <silent> [CamelCaseMotion]w <Plug>CamelCaseMotion_w
  nmap <silent> [CamelCaseMotion]b <Plug>CamelCaseMotion_b
  nmap <silent> [CamelCaseMotion]e <Plug>CamelCaseMotion_e

  omap <silent> [CamelCaseMotion]w <Plug>CamelCaseMotion_w
  omap <silent> [CamelCaseMotion]b <Plug>CamelCaseMotion_b
  omap <silent> [CamelCaseMotion]e <Plug>CamelCaseMotion_e

  xmap <silent> [CamelCaseMotion]w <Plug>CamelCaseMotion_w
  xmap <silent> [CamelCaseMotion]b <Plug>CamelCaseMotion_b
  xmap <silent> [CamelCaseMotion]e <Plug>CamelCaseMotion_e
'''

[[plugins]]
repo = 'kana/vim-smartword'
depends = 'CamelCaseMotion'
hook_post_source = '''
  " support CamelCaseMotion combine
  map <Plug>(smartword-basic-w)  <Plug>CamelCaseMotion_w
  map <Plug>(smartword-basic-b)  <Plug>CamelCaseMotion_b
  map <Plug>(smartword-basic-e)  <Plug>CamelCaseMotion_e

  " not support ge
  map w  <Plug>(smartword-w)
  map b  <Plug>(smartword-b)
  map e  <Plug>(smartword-e)
  map ge <Plug>(smartword-ge)

  xmap w  <Plug>(smartword-w)
  xmap b  <Plug>(smartword-b)
  xmap e  <Plug>(smartword-e)
  xmap ge <Plug>(smartword-ge)

  " " basic map
  " map <Leader>w  <Plug>(smartword-w)
  " map <Leader>b  <Plug>(smartword-b)
  " map <Leader>e  <Plug>(smartword-e)
  " map <Leader>ge <Plug>(smartword-ge)
  " " direct normally
  " noremap <Leader>w  w
  " noremap <Leader>b  b
  " noremap <Leader>e  e
  " noremap <Leader>ge ge

'''

[[plugins]]
repo = 'kana/vim-niceblock'

[[plugins]]
repo = 'kana/vim-gf-user'

[[plugins]]
repo = 'kana/vim-gf-diff'
depends = 'vim-gf-user'

[[plugins]]
repo = 'sgur/vim-gf-autoload'
depends = 'vim-gf-user'

[[plugins]]
repo = 'haya14busa/vim-signjk-motion'

[[plugins]]
repo = 'easymotion/vim-easymotion'
depends = ['vim-repeat', 'vim-signjk-motion']
hook_add = '''
  " based on http://haya14busa.com/mastering-vim-easymotion/
  " based on http://haya14busa.com/vim_migemo_search/
  " based on http://haya14busa.com/vim-lazymotion-on-speed/
  " based on http://haya14busa.com/vim-easymotion-ver-3-dot-0-overwin-motions/

  " Disable default mapping
  let g:EasyMotion_do_mapping = 0

  " if executable('cmigemo')
  " endif
  " Â∏∏„Å´Ë®≠ÂÆö
  let g:EasyMotion_use_migemo = 1

  " smartcase
  let g:EasyMotion_smartcase = 1
  let g:EasyMotion_use_smartsign_jp = 1

  " use repeat '.'
  let g:EasyMotion_keys='hklyuiopnm,qwertzxcvbasdgjf;'

  " Jump to first match with enter & space
  let g:EasyMotion_enter_jump_first = 1
  let g:EasyMotion_space_jump_first = 1
'''
hook_post_source = '''
  " prefix define (use other plugin)
  map <Leader> <Plug>(easymotion-prefix)

  " <Leader>f{char} to move to {char}
  map  <Leader>f <Plug>(easymotion-bd-f)
  nmap <Leader>f <Plug>(easymotion-overwin-f)

  " s{char}{char} to move to {char}{char}
  " map s <Plug>(easymotion-bd-f2)
  map ss <Plug>(easymotion-bd-f2)
  " nmap s <Plug>(easymotion-overwin-f2)
  nmap ss <Plug>(easymotion-overwin-f2)

  " Move to line
  " omap <Leader>L <Plug>(textobj-signjk-lines)
  " vmap <Leader>L <Plug>(textobj-signjk-lines)
  map <Leader>L <Plug>(easymotion-bd-jk)
  nmap <Leader>L <Plug>(easymotion-overwin-line)
  " JK motions: Line motions
  " map <Leader>j <Plug>(signjk-j)
  " map <Leader>k <Plug>(signjk-k)
  map <Leader>j <Plug>(easymotion-j)
  map <Leader>k <Plug>(easymotion-k)

  " Move to word
  map  <Leader>w <Plug>(easymotion-bd-w)
  nmap <Leader>w <Plug>(easymotion-overwin-w)
'''

[[plugins]]
repo = 'junegunn/vim-easy-align'
hook_add = '''
  let g:easy_align_bypass_fold = 1
'''
hook_post_source = '''
  " see https://wonderwall.hatenablog.com/entry/2016/03/29/215904
  " map to gA
  " Start interactive EasyAlign for a motion/text object (e.g. gAip)
  nmap gA <Plug>(EasyAlign)
  " Start interactive EasyAlign in visual mode (e.g. vipgA)
  xmap gA <Plug>(EasyAlign)
'''

[[plugins]]
repo = 'severin-lemaignan/vim-minimap'
# repo = 'koron/minimap-vim'
hook_post_source = '''
  nmap <silent> <F7> :MinimapToggle<CR>
'''

[[plugins]] # Doxygen
repo = 'vim-scripts/DoxygenToolkit.vim'
# repo = 'JohnBro/DoxygenToolkit.vim'
depends = ['vital.vim', 'vim-fileheader'] # use setting
hook_post_source = '''
  let s:now  = g:V.import('DateTime').now()
  let s:year = string(s:now.year())

  " basic
  " let g:DoxygenToolkit_briefTag_pre = '@brief '
  " let g:DoxygenToolkit_briefTag_post = ''
  " let g:DoxygenToolkit_templateParamTag_pre = '@tparam '
  " let g:DoxygenToolkit_templateParamTag_post = ''
  " let g:DoxygenToolkit_paramTag_pre = '@param '
  " let g:DoxygenToolkit_paramTag_post = ''
  " let g:DoxygenToolkit_returnTag = '@return '
  " let g:DoxygenToolkit_throwTag_pre = '@throw ' " @exception is also valid
  " let g:DoxygenToolkit_throwTag_post = ''

  " let g:DoxygenToolkit_fileTag = '@file '
  " let g:DoxygenToolkit_authorTag = '@author '
  " let g:DoxygenToolkit_dateTag = '@date '
  " let g:DoxygenToolkit_versionTag = '@version '
  " let g:DoxygenToolkit_undocTag = 'DOX_SKIP_BLOCK'
  " let g:DoxygenToolkit_blockTag = '@name '
  " let g:DoxygenToolkit_classTag = '@class '

  " format tuning : default OK
  " let g:DoxygenToolkit_cinoptions = 'c1C1'

  " Work area format
  " simple delay (git user/email async get in fileheader plugin)
  let g:DoxygenToolkit_authorName = g:user.git.name " use current develop user name

  " projct specfic
  " let g:DoxygenToolkit_blockHeader = ''
  " let g:DoxygenToolkit_blockFooter = ''
  " let g:DoxygenToolkit_licenseTag = 'need simple license string: (C) 2009 - ' . s:year . ' xxx Corporation All rights reserved.'
  " let g:DoxygenToolkit_versionString = 1.0

  " let g:DoxygenToolkit_compactOneLineDoc = 'no'
  " let g:DoxygenToolkit_compactDoc = 'no'
  " let g:DoxygenToolkit_ignoreForReturn =

  " Style
  " let g:DoxygenToolkit_commentType = 'C++'
  let g:DoxygenToolkit_commentType = 'C'
  " C type
  " let g:DoxygenToolkit_startCommentTag = '/** '
  " let g:DoxygenToolkit_startCommentBlock = '/* '
  " let g:DoxygenToolkit_interCommentTag = '* '
  " let g:DoxygenToolkit_interCommentBlock = '* '
  " let g:DoxygenToolkit_endCommentTag = '*/'
  " let g:DoxygenToolkit_endCommentBlock = '*/'

  " C++ type
  " let g:DoxygenToolkit_startCommentTag = '/// '
  " let g:DoxygenToolkit_startCommentBlock = '// '
  " let g:DoxygenToolkit_interCommentTag = '/// '
  " let g:DoxygenToolkit_interCommentBlock = '// '
  " let g:DoxygenToolkit_endCommentTag = ''
  " let g:DoxygenToolkit_endCommentBlock = ''

  " need tuning
  " let g:DoxygenToolkit_maxFunctionProtoLines = 10

  " let g:DoxygenToolkit_briefTag_className = 'no'
  " let g:DoxygenToolkit_briefTag_structName = 'no'
  " let g:DoxygenToolkit_briefTag_enumName = 'no'
  " let g:DoxygenToolkit_briefTag_namespaceName = 'no'
  " let g:DoxygenToolkit_briefTag_funcName = 'no'

  " let g:DoxygenToolkit_keepEmptyLineAfterComment = 'no'

  " let g:DoxygenToolkit_python_autoRemoveSelfParam = 'yes'
  " let g:DoxygenToolkit_python_autoFunctionReturn = 'yes'
'''

[[plugins]] # Doxygen and other
repo = 'kkoomen/vim-doge'

[[plugins]] # PowerShell
repo = 'PProvost/vim-ps1'

[[plugins]]
repo = 'liuchengxu/vista.vim'
# repo = 'tsuyoshicho/vista.vim'
# rev  = 'develop'
depends = ['vim-lsp', 'lightline.vim', 'fzf', 'fzf.vim']
hook_add = '''
  " indent
  let g:vista_icon_indent = ["‚ï∞‚îÄ‚ñ∏ ", "‚îú‚îÄ‚ñ∏ "]

  " default ctags
  let g:vista_default_executive = 'ctags'

  " lsp enable
  let g:vista_executive_for = {
  \ 'cpp'      : 'vim_lsp',
  \ 'sh'       : 'vim_lsp',
  \ 'vim'      : 'vim_lsp',
  \ 'python'   : 'vim_lsp',
  \ 'markdown' : 'toc',
  \ }

  let g:vista_update_on_text_changed = 1

  " Ensure you have installed some decent font to show these pretty symbols, then you can enable icon for the kind.
  let g:vista#renderer#enable_icon = 1

  " The default icons can't be suitable for all the filetypes, you can extend it as you wish.
  let g:vista#renderer#icons = {
  \   "function": nr2char(0xf0ad),
  \   "variable": nr2char(0xf0ae),
  \  }
  "\   "function": nr2char(0xf0ad),  " 0xf0ad ÔÇ≠
  "\   "variable": nr2char(0xf0ae),  " 0xf0ae ÔÇÆ
  "\   "function": nr2char(0xf794),  " 0xf794 Ûøûî
  "\   "variable": nr2char(0xf71b),  " 0xf71b Ûøúõ

  function! NearestMethodOrFunction() abort
    return get(b:, 'vista_nearest_method_or_function', '')
  endfunction
  augroup vimrc_init-vista
    autocmd!
    autocmd VimEnter,BufEnter,BufWinEnter,InsertEnter *
      \ nested call vista#RunForNearestMethodOrFunction()
    autocmd User                                      lsp_server_init
      \ nested call vista#RunForNearestMethodOrFunction()
  augroup END
'''
hook_post_source = '''
  nnoremap <silent> <F8> :Vista!!<CR>

  nnoremap <silent> <leader>vv :Vista!!<CR>
  nnoremap <silent> <leader>vf :Vista finder<CR>
'''

# [[plugins]] # Chrome/Firefox GhostText Extention
# repo = 'pandysong/ghost-text.vim'

[[plugins]] # GnuPG Encrypt
repo = 'jamessan/vim-gnupg'

# [[plugins]] # RFC
# repo = 'zh4ui/vim-rfc-reader'
# hook_add = '''
#   " vim-ref rfc„Å®ÈÄ£Êê∫
#   autocmd MyAutoGroup FileType ref-rfc nested setlocal filetype=rfc
# '''

[[plugins]] # RFC
repo = 'vim-scripts/rfc-syntax'
# repo = 'dhulihan/vim-rfc'
hook_add = '''
  " vim-ref rfc„Å®ÈÄ£Êê∫
  autocmd MyAutoGroup FileType ref-rfc nested setlocal filetype=rfc
'''

[[plugins]] # vimref
repo = 'cowsys/ctrlp-vimref'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['vimref']
'''

[[plugins]] # Qiita
repo = 'mattn/qiita-vim'
depends = ['ctrlp.vim']
hook_add = '''
  let g:ctrlp_extensions = get(g:, 'ctrlp_extensions', [])
        \ + ['qiita']
'''

[[plugins]] # Slack
repo = 'higashi000/sarahck.vim'
depends = ['slackstatus.vim', 'webapi-vim','vim-pass']

[[plugins]] # Slack
repo = 'mizukmb/slackstatus.vim'
depends = ['webapi-vim','vim-pass']
hook_add = '''
  " slackstatus.vim use g:slackstatus_token
  " sarahck.vim     use g:slackToken
  " team m-falcon
  call pass#get_startup('g:slackstatus_token','Message/Slack/team-m-falcon.legacy')
  call pass#get_startup('g:slackToken',       'Message/Slack/team-m-falcon.legacy')
  " vim-jp
  " call pass#get_startup('g:slackstatus_token','Message/Slack/vim-jp.legacy')
  " call pass#get_startup('g:slackToken',       'Message/Slack/vim-jp.legacy')


  function! s:slack_team_completion(A,L,P) abort
    let team_list = ['team-m-falcon','vim-jp']
    return join(team_list,"\n")
  endfunction

  function! s:slack_token_change(team) abort
    let path = 'Message/Slack/' . a:team . '.legacy'

    let token = pass#get(path)

    let g:slackstatus_token = token
    let g:slackToken        = token
  endfunction

  command! -nargs=1 -complete=custom,<SID>slack_team_completion SlackWorkspaceChange :call <SID>slack_token_change(<f-args>)
'''

[[plugins]] # Mastodon
repo = 'mattn/vim-mastodon'
depends = ['webapi-vim','vim-pass']
hook_add = '''
  " mstdn.jp
  let g:mastodon_host = 'mstdn.jp'
  call pass#get_startup('g:mastodon_access_token','Message/Mastodon/mstdn.jp')

  function! s:mastodon_completion(A,L,P) abort
    let host_list = ['mstdn.jp']
    return join(host_list,"\n")
  endfunction

  function! s:mastodon_change_hosttoken(host) abort
    let path = 'Message/Mastodon/' . a:host
    let g:mastodon_host = a:host
    let g:mastodon_access_token = pass#get(path)
  endfunction

  command! -nargs=1 -complete=custom,<SID>mastodon_completion MastodonHostChange :call <SID>mastodon_change_hosttoken(<f-args>)
'''

[[plugins]] # man
repo = 'lambdalisue/vim-manpager'

[[plugins]] # fzf
repo = 'junegunn/fzf'
merged = 0

[[plugins]]
repo = 'junegunn/fzf.vim'
merged = 0
depends = ['fzf']
hook_add = '''
  let g:fzf_command_prefix = 'Fzf'

  " fzf„Åã„Çâ„Éï„Ç°„Ç§„É´„Å´„Ç∏„É£„É≥„Éó„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã
  let g:fzf_buffers_jump = 1

  " Customize fzf colors to match your color scheme
  let g:fzf_colors = {
        \ 'fg':      ['fg', 'Normal'],
        \ 'bg':      ['bg', 'Normal'],
        \ 'hl':      ['fg', 'Comment'],
        \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
        \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
        \ 'hl+':     ['fg', 'Statement'],
        \ 'info':    ['fg', 'PreProc'],
        \ 'border':  ['fg', 'Ignore'],
        \ 'prompt':  ['fg', 'Conditional'],
        \ 'pointer': ['fg', 'Exception'],
        \ 'marker':  ['fg', 'Keyword'],
        \ 'spinner': ['fg', 'Label'],
        \ 'header':  ['fg', 'Comment'],
        \}
'''
hook_post_source = '''
  " see https://qiita.com/hisawa/items/fc5300a526cb926aef08
  " ,<C-]>„Åß„Çø„Ç∞Ê§úÁ¥¢
  nnoremap <silent> <leader><C-]> :call fzf#vim#tags(expand('<cword>'))<CR>

  " based on https://qiita.com/Sa2Knight/items/6635af9fc648a5431685
  nnoremap [fzf]     <Nop>
  nmap     <leader>z [fzf]

  function! s:fzf_command(cmd) abort
    return g:fzf_command_prefix . a:cmd
  endfunction

  nnoremap <silent><expr> [fzf]f ':' . <SID>fzf_command('GFiles')  . '<CR>'
  nnoremap <silent><expr> [fzf]F ':' . <SID>fzf_command('GFiles?') . '<CR>'
  nnoremap <silent><expr> [fzf]b ':' . <SID>fzf_command('Buffers') . '<CR>'
  nnoremap <silent><expr> [fzf]l ':' . <SID>fzf_command('BLines')  . '<CR>'
  nnoremap <silent><expr> [fzf]h ':' . <SID>fzf_command('History') . '<CR>'
  nnoremap <silent><expr> [fzf]m ':' . <SID>fzf_command('Mark')    . '<CR>'
'''

# [[plugins]] # fzf
# repo = 'yuki-ycino/fzf-preview.vim'
# depends = ['fzf', 'vim-devicons']
# hook_add = '''
#   " filelist preview
#   if executable('bat')
#     let g:fzf_preview_command = 'bat --color=always --style=grid {-1}'
#   else
#     let g:fzf_preview_command = 'head -100 {-1}'
#   endif
#
#   " filelist command
#   " let g:fzf_preview_filelist_command
#   " grep command
#   " let g:fzf_preview_grep_cmd
#
#   " filelist post process
#   if executable('exa')
#     let g:fzf_preview_filelist_postprocess_command = 'xargs -d "\n" exa --color=always'
#   else
#     let g:fzf_preview_filelist_postprocess_command = ''
#   endif
#
#   " Use vim-devicons
#   let g:fzf_preview_use_dev_icons = 1
#
#   if g:user.system.windows
#     let g:fzf_preview_use_floating_window = 0
#     let g:fzf_preview_layout = 'top split new'
#   endif
# '''

[[plugins]] # fzf
repo = 'n04ln/yankee.vim'
depends = ['fzf']
hook_add = '''
  let g:yankee_buf_list = [
        \ '""', '"*', '"+', '"^',
        \ '":', '".', '"%',
        \ '"0', '"1', '"2', '"3', '"4', '"5', '"6', '"7', '"8', '"9',
        \ '"a', '"b', '"c', '"d', '"e', '"f', '"g', '"h', '"i', '"j',
        \]
'''

[[plugins]] # orgmode
repo = 'jceb/vim-orgmode'

[[plugins]] # memo
repo = 'Shougo/junkfile.vim'
hook_add = '''
  let g:junkfile#directory = expand(g:user.dir.cache_home . '/junkfile')
  call g:user.function.mkdir(g:junkfile#directory)
'''

[[plugins]] # memo
repo = 'mattn/vim-gist'
depends = ['vim-pass']
hook_add = '''
  " let g:gist_token = '<token>'
  call pass#get_startup('g:github_user','Develop/Github','username')
  call pass#get_startup('g:gist_token','Develop/Github')
'''

[[plugins]] # memo
repo = 'glidenote/memolist.vim'
depends = ['ctrlp.vim']
hook_add = '''
  let g:memolist_path = expand(g:user.dir.vim . '/memo')
  call g:user.function.mkdir(g:memolist_path)
  let g:memolist_template_dir_path = expand(g:user.dir.config_home . '/template/memo')
  call g:user.function.mkdir(g:memolist_template_dir_path)

  nnoremap <silent> <Leader>mn  :<C-u>MemoNew<CR>
  nnoremap <silent> <Leader>ml  :<C-u>MemoList<CR>
  nnoremap <silent> <Leader>mg  :<C-u>MemoGrep<CR>

  " suffix type (default markdown)
  let g:memolist_memo_suffix = "md"

  " date format (default %Y-%m-%d %H:%M)
  " ISO8601
  " let g:memolist_memo_date = "%FT%T%z"
  let g:memolist_memo_date = "%F"

  " tags prompt (default 0)
  " let g:memolist_prompt_tags = 1

  " categories prompt (default 0)
  let g:memolist_prompt_categories = 1

  " use qfixgrep (default 0)
  " let g:memolist_qfixgrep = 1

  " use vimfiler (default 0)
  " let g:memolist_vimfiler = 1

  " use fzf (default 0)
  " let g:memolist_fzf = 1

  " remove filename prefix (default 0)
  " let g:memolist_filename_prefix_none = 1

  " use unite (default 0)
  " let g:memolist_unite = 1

  " use arbitrary unite source (default is 'file')
  " let g:memolist_unite_source = "file_rec"

  " use arbitrary unite option (default is empty)
  " let g:memolist_unite_option = "-auto-preview -start-insert"

  " use denite (default 0)
  " let g:memolist_denite = 1

  " use arbitrary denite source (default is 'file_rec')
  " let g:memolist_denite_source = "anything"

  " use arbitrary denite option (default is empty)
  " let g:memolist_denite_option = "anything"

  " use various Ex commands (default '')
  let g:memolist_ex_cmd = 'CtrlP'

  " use delimiter of array in yaml front matter (default is ' ')
  let g:memolist_delimiter_yaml_array = ','

  " use when get items from yaml front matter
  " first line string pattern of yaml front matter (default "==========")
  let g:memolist_delimiter_yaml_start = "---"

  " last line string pattern of yaml front matter (default "- - -")
  let g:memolist_delimiter_yaml_end  = "---"
'''

[[plugins]] # cheat sheet
repo = 'reireias/vim-cheatsheet'
hook_add = '''
  let g:cheatsheet#cheat_file = expand(g:user.dir.vim. '/cheatsheet.md')
  let g:cheatsheet#vsplit = 1

  " augroup vimrc_init-cheatsheet
  "   autocmd!
  "   if ale
  "   autocmd BufEnter g:cheatsheet#cheat_file nested ALEDisableBuffer
  " augroup END
'''

[[plugins]] # detect shebang
repo = 'vitalk/vim-shebang'

[[plugins]]
repo = 'yasuhiroki/github-actions-yaml.vim'

[[plugins]]
repo = 'mattn/vim-maketable'
depends = ['vim-altercmd']
hook_post_source = '''
  AlterCommand          maketable MakeTable
  AlterCommand <cmdwin> maketable MakeTable
'''

[[plugins]]
repo = 'dhruvasagar/vim-table-mode'
depends = ['vim-submode']
hook_add = '''
  augroup vimrc_init-vim-table-mode
    autocmd!
    autocmd FileType markdown,rst nested if tablemode#IsActive() == 0 | call tablemode#Enable() | endif
  augroup END

  let g:table_mode_map_prefix = '<Leader>T'
'''
hook_post_source = '''
  " table move
  call submode#enter_with('tablemove', 'n', '',  g:table_mode_map_prefix . 'M')
  call submode#map('tablemove', 'n', 'r', 'k', '<Plug>(table-mode-motion-up)'   )
  call submode#map('tablemove', 'n', 'r', 'j', '<Plug>(table-mode-motion-down)' )
  call submode#map('tablemove', 'n', 'r', 'h', '<Plug>(table-mode-motion-left)' )
  call submode#map('tablemove', 'n', 'r', 'l', '<Plug>(table-mode-motion-right)')
'''

# EOF
